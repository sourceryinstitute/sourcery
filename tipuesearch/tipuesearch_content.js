var tipuesearch = {"pages":[{"title":" ","text":"Sourcery Library A grab bag of useful tricks in Fortran 2018. - : /+- . / oydddy / . . / sdmNNmmdh / . / odNNmNmyshdh / . -+ ymNNmmms ... ohy . . + odmNNmdmm + . ... -+ sdmNNNmdmmo . /+ ydmNNNmddmms - -+ ohmmNNNNmddmmy : /+ ohmmNNNNmdhdmmy / . . ++ shdmNNNNNmdhdmmh / . : /+ shdmmNNNNmdhhmmmy / . . +/+ shdmmNNNNNmdhdmmm ## ............. -//+ shdmmNNNNNmdhyyy ## -- sssssssssssso +- . .. - ## /+ shdmmmNNNNmhs / ## //+ sdhhhyyhddhso +++ : ..: oyh ## /+ shdmmmNNNds ## syyyyhhhhhhhdho - . .: oyhhdmh ## /+ shddmddy + ## + hdysoosyys /- .. . / ssssyhdmd : - ## ////// ## ndifmdhyooo +- : ooo + oosyhdmdyo + ###### ydmNNNNNmhs / . : +++///++ osyhhhdmmmmmNNNNNNNNmdo - +++//////+ oossshddmmmmmNNNmdy / . . ///////+++ oosyhhddmmmmddy / . .: ////+++ ossyyhhhhhs + :. --- .......... -- This library gathers software that developers at Archaeologic Inc. and Sourcery Institute find useful across many of our projects, including in\ncourses that we teach.  Most code starts here because it is too limited in \ncapability to release as a standalone package but too distinct in purpose to \nfold into other existing packages.  Over time, when code that starts here grows\nin capability, a new repository is born and the corresponding code is removed\nfrom the Sourcery repository.  Examples include the Assert and Emulators libraries.  Following the practice of semantic versioning , code removal\ncauses an increment in the major version number. Contents Procedures Array functions String functions User-defined collective subroutines Input/output format strings and format string generators Classes Parallel data partitioning and gathering, A minimalistic unit testing framework comprised of two types: test_t and test_result_t (Co-) Object pattern abstract parent, Runtime units tracking, A test oracle using the Template Method pattern , and A command-line abstraction that searches for program arguments. Documentation See the Sourcery GitHub Pages site for HTML documentation generated with [ ford ]: Prerequisites FORD 6.1.0 or later is required for producing HTML documentation (see\n\" Building the documentation \" below for instructions).  The Fortran Package\nManager ( fpm ) is required to build Sourcery from source.  See the fpm manifest for the dependencies and developer dependencies,\nall of which fpm automatically downloads and builds via the fpm command\nprovided in the \" Downloding, Building, and Testing \" section below. Downloding, Building, and Testing With recent versions of GNU Fortran (gfortran) and OpenCoarrays installed, \nexecute the following command in a zsh or bash -like shell: git clone git@github.com:sourceryinstitute/sourcery\nfpm test --compiler caf --runner \"cafrun -n 4\" substituting the number of desired images for the \"4\" above. Building the documentation After installing ford , execute the following command in a zsh or bash -like\nshell: ford doc/ford-documentation.md after which opening subdirectory doc/html/index.html in a browser displays the\ndocumentation. Developer Info Damian Rouson","tags":"home","loc":"index.html"},{"title":"command_line_t –  ","text":"type, public :: command_line_t Contents Type-Bound Procedures argument_present flag_value Type-Bound Procedures procedure, public, nopass :: argument_present interface private module module function argument_present(acceptable_argument) result(found) Implementation → result is .true. only if a command-line argument matches an element of this function's argument Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: acceptable_argument (:) sample list: [character(len=len( )):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS, slashes support Windows, and must be replaced\nby the longest list element (\"--benchmark\" above) Return Value logical procedure, public, nopass :: flag_value interface private module module function flag_value(flag) Implementation → result is the value passed adjacent to a command-line flag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flag Return Value character(len=:),allocatable","tags":"","loc":"type/command_line_t.html"},{"title":"test_result_t –  ","text":"type, public :: test_result_t Encapsulate test descriptions and outcomes and reporting Contents Variables description_ passed_ Constructor test_result_t Type-Bound Procedures characterize passed Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: description_ logical, private :: passed_ Constructor public interface test_result_t private elemental module function construct(description, passed) result(test_result) The result is a test_result_t object with the components defined by the dummy arguments Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description logical, intent(in) :: passed Return Value type( test_result_t ) Type-Bound Procedures procedure, public :: characterize interface private pure module module function characterize(self) result(characterization) Implementation → The result is a character description of the test and its outcome Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value character(len=:),allocatable procedure, public :: passed interface private elemental module module function passed(self) result(test_passed) Implementation → The result is a character description of the test and its outcome Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/test_result_t.html"},{"title":"file_t –  ","text":"type, public :: file_t Inherits type~~file_t~~InheritsGraph type~file_t file_t type~string_t string_t type~file_t->type~string_t lines_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lines_ Constructor file_t Type-Bound Procedures lines write_lines Components Type Visibility Attributes Name Initial type( string_t ), private, allocatable :: lines_ (:) Constructor public interface file_t private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: file_name Return Value type( file_t ) Type-Bound Procedures procedure, public :: lines interface private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type( string_t ),allocatable, (:) procedure, public :: write_lines interface private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type( string_t ), intent(in), optional :: file_name","tags":"","loc":"type/file_t.html"},{"title":"oracle_t –  ","text":"type, public, abstract, extends( object_t ) :: oracle_t define procedures for testing output values against expected values Inherits type~~oracle_t~~InheritsGraph type~oracle_t oracle_t type~object_t object_t type~oracle_t->type~object_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures mark_as_defined norm operator(-) subtract user_defined within_tolerance write(formatted) write_formatted Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module module subroutine mark_as_defined(self) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self procedure( norm_interface ), public, deferred :: norm pure function norm_interface(self) result(norm_of_self) Prototype result is a norm of the array formed by concatenating the real components of self object Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self Return Value real generic, public :: operator(-) => subtract function subtract_interface(self, rhs) result(difference) Prototype result has components corresponding to subtracting rhs's components fron self object's components Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: rhs Return Value class( oracle_t ),allocatable procedure( subtract_interface ), public, deferred :: subtract function subtract_interface(self, rhs) result(difference) Prototype result has components corresponding to subtracting rhs's components fron self object's components Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: rhs Return Value class( oracle_t ),allocatable procedure, public :: user_defined interface private pure module module function user_defined(self) result(is_defined) Implementation → Return a boolean result indicating whether self object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical procedure, public :: within_tolerance interface private module module function within_tolerance(self, reference, tolerance) result(in_tolerance) Implementation → template method with true result iff the difference in state vectors (self - reference) has a norm within tolerance\n(impure because of internal call to 'subtract' binding)\nThe existence of self procedure eliminates the need to rewrite similar code for every oracle child type. Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: reference real, intent(in) :: tolerance Return Value logical generic, public :: write(formatted) => write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg procedure( write_interface ), public, deferred :: write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg","tags":"","loc":"type/oracle_t.html"},{"title":"data_partition_t –  ","text":"type, public :: data_partition_t encapsulate a description of the data subset the executing image owns Contents Type-Bound Procedures define_partitions first gather last gather_real32_1D_array gather_real32_2D_array gather_real64_1D_array gather_real64_2D_array Type-Bound Procedures procedure, public, nopass :: define_partitions interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine define_partitions(cardinality) Implementation → define the range of data identification numbers owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality procedure, public, nopass :: first interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private pure module module function first(image_number) result(first_index) Implementation → the result is the first identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer generic, public :: gather => gather_real32_2D_array , gather_real64_2D_array , gather_real32_1D_array , gather_real64_1D_array private interface gather_real32_2D_array () Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Arguments None private interface gather_real64_2D_array () Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Arguments None private interface gather_real32_1D_array () Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Arguments None private interface gather_real64_1D_array () Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Arguments None procedure, public, nopass :: last interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private pure module module function last(image_number) result(last_index) Implementation → the result is the last identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer procedure, private, nopass :: gather_real32_1D_array interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real32_1D_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim procedure, private, nopass :: gather_real32_2D_array interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real32_2D_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim procedure, private, nopass :: gather_real64_1D_array interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real64_1D_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim procedure, private, nopass :: gather_real64_2D_array interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real64_2D_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim","tags":"","loc":"type/data_partition_t.html"},{"title":"co_object –  ","text":"type, public, abstract :: co_object Contents Variables defined facilitate_type_extension Type-Bound Procedures mark_as_defined user_defined Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined logical, private, allocatable :: facilitate_type_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module module subroutine mark_as_defined(self) Implementation → Mark the co_object as user-defined Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: self procedure, public :: user_defined interface private pure module module function user_defined(self) result(is_defined) Implementation → Return a boolean result indicating whether self co_object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: self Return Value logical","tags":"","loc":"type/co_object.html"},{"title":"units –  ","text":"type, public :: units Morfeus universal base type for all units Contents Variables description exponents_ system Type-Bound Procedures add assign_units assignment(=) divide get_system get_units has_density_units has_energy_units has_length_units has_mass_units has_power_units has_specific_energy_units has_stress_units has_temperature_units has_time_units has_velocity_units integer_power is_dimensionless multiply negate operator(*) operator(**) operator(+) operator(-) operator(/) real_power set_units subtract Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: description integer, private :: exponents_ (num_fundamental) = dimensionless Store the exponents for fundamental units integer, private :: system = dimensionless Default to SI units Type-Bound Procedures procedure, public :: add interface private impure elemental module module function add(lhs, rhs) result(total) Implementation → result is the units of the sum of two dimensional quantities; includes operand consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) procedure, public :: assign_units interface private pure module module subroutine assign_units(lhs, rhs) Implementation → copy units information Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: lhs class( units ), intent(in) :: rhs generic, public :: assignment(=) => assign_units private interface assign_units () Arguments None procedure, public :: divide interface private elemental module module function divide(numerator, denominator) result(ratio) Implementation → result is the units of the ratio of two dimensional quantities; includes units-sysetm consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: numerator class( units ), intent(in) :: denominator Return Value type( units ) procedure, public :: get_system interface private impure elemental module module function get_system(this) result(system_of_units) Implementation → result is enumerated value designating units system Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer procedure, public :: get_units interface private module module function get_units(this) result(exponents) Implementation → result holds the exponents of each unit in the argument (most useful when the actual argument is an expression) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer(num_fundamental) procedure, public :: has_density_units interface private elemental module module function has_density_units(this) result(density_units) Implementation → Return true if units match kilograms (kg/m&#94;3) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_energy_units interface private elemental module module function has_energy_units(this) result(energy_units) Implementation → Return true if units match joules (J) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_length_units interface private elemental module module function has_length_units(this) result(length_units) Implementation → Return true if units match meters (m) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_mass_units interface private elemental module module function has_mass_units(this) result(mass_units) Implementation → Return true if units match kilograms (kg) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_power_units interface private elemental module module function has_power_units(this) result(power_units) Implementation → Return true if units match Watts (W) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_specific_energy_units interface private elemental module module function has_specific_energy_units(this) result(specific_energy_units) Implementation → Return true if units match Joules per kilogram (J/kg) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_stress_units interface private elemental module module function has_stress_units(this) result(stress_units) Implementation → Return true if units match Newtons per square meter (N/m&#94;2) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_temperature_units interface private elemental module module function has_temperature_units(this) result(temperature_units) Implementation → Return true if units match degrees Kelvin (K) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_time_units interface private elemental module module function has_time_units(this) result(time_units) Implementation → Return true if units match seconds (s) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: has_velocity_units interface private elemental module module function has_velocity_units(this) result(velocity_units) Implementation → Return true if units match meters/second&#94;2 (m/s&#94;2) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: integer_power interface private impure elemental module module function integer_power(this, exponent_) result(this_raised) Implementation → result has units of the opearand raised to the power \"exponent_\" Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this integer, intent(in) :: exponent_ Return Value type( units ) procedure, public :: is_dimensionless interface private elemental module module function is_dimensionless(this) result(nondimensional) Implementation → Return true if all units exponents are zero; false otherwise. Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical procedure, public :: multiply interface private elemental module module function multiply(lhs, rhs) result(product_) Implementation → result is the units of the product of two dimensional quantities; includes units-system consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) procedure, public :: negate interface private elemental module module function negate(this) result(negative_this) Implementation → result is the units of the negative of a dimensional quantities Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value type( units ) generic, public :: operator(*) => multiply private interface multiply () Arguments None generic, public :: operator(**) => integer_power , real_power private interface integer_power () Arguments None private interface real_power () Arguments None generic, public :: operator(+) => add private interface add () Arguments None generic, public :: operator(-) => subtract , negate private interface subtract () Arguments None private interface negate () Arguments None generic, public :: operator(/) => divide private interface divide () Arguments None procedure, public :: real_power interface private impure elemental module module function real_power(this, exponent_) result(this_raised) Implementation → result is the units of the operand raised to the power \"exponent_\"; includes check that operand is dimensionless Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this real, intent(in) :: exponent_ Return Value type( units ) procedure, public :: set_units interface private pure module module subroutine set_units(this, exponents, system) Implementation → define units Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: this integer, intent(in) :: exponents (num_fundamental) integer, intent(in) :: system procedure, public :: subtract interface private impure elemental module module function subtract(lhs, rhs) result(difference) Implementation → result is the units of the difference of two dimensional quantities; includes operand consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units )","tags":"","loc":"type/units.html"},{"title":"string_t –  ","text":"type, public :: string_t Inherited by type~~string_t~~InheritedByGraph type~string_t string_t type~file_t file_t type~file_t->type~string_t lines_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables string_ Constructor string_t Type-Bound Procedures is_allocated string Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: string_ Constructor public interface string_t private elemental module function construct(string) result(new_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( string_t ) Type-Bound Procedures procedure, public :: is_allocated interface private elemental module module function is_allocated(self) result(string_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value logical procedure, public :: string interface private pure module module function string(self) result(raw_string) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value character(len=:),allocatable","tags":"","loc":"type/string_t.html"},{"title":"object_t –  ","text":"type, public, abstract :: object_t Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types.\nEach non-abstract type provides the functionality by extending self type and implementing its deferred binding(s).  This\ntype resembles java's Object class in the sense that it is intended to be the ultimate ancestor of every other type. Inherited by type~~object_t~~InheritedByGraph type~object_t object_t type~oracle_t oracle_t type~oracle_t->type~object_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables defined Type-Bound Procedures mark_as_defined user_defined write(formatted) write_formatted Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined Type-Bound Procedures procedure, public :: mark_as_defined interface private pure module module subroutine mark_as_defined(self) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self procedure, public :: user_defined interface private pure module module function user_defined(self) result(is_defined) Implementation → Return a boolean result indicating whether self object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical generic, public :: write(formatted) => write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg procedure( write_interface ), public, deferred :: write_formatted subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg","tags":"Morfeus-FD","loc":"type/object_t.html"},{"title":"test_t –  ","text":"type, public, abstract :: test_t Facilitate testing and test reporting Contents Type-Bound Procedures report results subject Type-Bound Procedures procedure, public :: report interface private module module subroutine report(test, passes, tests) Implementation → Print the test results and increment the tallies of passing tests and total tests Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: test integer, intent(inout) :: passes integer, intent(inout) :: tests procedure( results_interface ), public, deferred, nopass :: results function results_interface() result(test_results) Prototype The result is an array of test results for subsequent reporting in the \"report\" type-bound procedure Arguments None Return Value type( test_result_t ),allocatable, (:) procedure( subject_interface ), public, deferred, nopass :: subject pure function subject_interface() result(specimen) Prototype The result is the name of the test specimen (the subject of testing) Arguments None Return Value character(len=:),allocatable","tags":"","loc":"type/test_t.html"},{"title":"norm_interface – ","text":"abstract interface private pure function norm_interface(self) result(norm_of_self) Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self Return Value real Description result is a norm of the array formed by concatenating the real components of self object","tags":"","loc":"interface/norm_interface.html"},{"title":"subtract_interface – ","text":"abstract interface private function subtract_interface(self, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: rhs Return Value class( oracle_t ),allocatable Description result has components corresponding to subtracting rhs's components fron self object's components","tags":"","loc":"interface/subtract_interface.html"},{"title":"write_interface – ","text":"abstract interface private subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg","tags":"","loc":"interface/write_interface.html"},{"title":"results_interface – ","text":"abstract interface private function results_interface() result(test_results) Arguments None Return Value type( test_result_t ),allocatable,(:) Description The result is an array of test results for subsequent reporting in the \"report\" type-bound procedure","tags":"","loc":"interface/results_interface.html"},{"title":"subject_interface – ","text":"abstract interface private pure function subject_interface() result(specimen) Arguments None Return Value character(len=:),allocatable Description The result is the name of the test specimen (the subject of testing)","tags":"","loc":"interface/subject_interface.html"},{"title":"argument_present – ","text":"interface Calls interface~~argument_present~~CallsGraph interface~argument_present argument_present proc~argument_present argument_present interface~argument_present->proc~argument_present acceptable_length acceptable_length proc~argument_present->acceptable_length Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function argument_present(acceptable_argument) result(found) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: acceptable_argument (:) sample list: [character(len=len( )):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS, slashes support Windows, and must be replaced\nby the longest list element (\"--benchmark\" above) Return Value logical Description result is .true. only if a command-line argument matches an element of this function's argument","tags":"","loc":"interface/argument_present.html"},{"title":"flag_value – ","text":"interface Calls interface~~flag_value~~CallsGraph interface~flag_value flag_value proc~flag_value flag_value interface~flag_value->proc~flag_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function flag_value(flag) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flag Return Value character(len=:),allocatable Description result is the value passed adjacent to a command-line flag","tags":"","loc":"interface/flag_value.html"},{"title":"separated_values – ","text":"interface Calls interface~~separated_values~~CallsGraph interface~separated_values separated_values proc~separated_values separated_values interface~separated_values->proc~separated_values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public pure module module function separated_values(separator, mold) result(format_string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: separator class(*), intent(in) :: mold (..) Return Value character(len=:),allocatable","tags":"","loc":"interface/separated_values.html"},{"title":"test_result_t – ","text":"public interface test_result_t Contents Functions construct Functions private elemental module function construct(description, passed) result(test_result) The result is a test_result_t object with the components defined by the dummy arguments Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description logical, intent(in) :: passed Return Value type( test_result_t )","tags":"","loc":"interface/test_result_t.html"},{"title":"characterize – ","text":"interface Calls interface~~characterize~~CallsGraph interface~characterize characterize proc~characterize characterize interface~characterize->proc~characterize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function characterize(self) result(characterization) Implementation → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value character(len=:),allocatable Description The result is a character description of the test and its outcome","tags":"","loc":"interface/characterize.html"},{"title":"passed – ","text":"interface Calls interface~~passed~~CallsGraph interface~passed passed proc~passed passed interface~passed->proc~passed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function passed(self) result(test_passed) Implementation → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical Description The result is a character description of the test and its outcome","tags":"","loc":"interface/passed.html"},{"title":"file_t – ","text":"public interface file_t Contents Functions construct read_lines Functions private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: file_name Return Value type( file_t )","tags":"","loc":"interface/file_t.html"},{"title":"lines – ","text":"interface Calls interface~~lines~~CallsGraph interface~lines lines proc~lines lines interface~lines->proc~lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type( string_t ),allocatable,(:)","tags":"","loc":"interface/lines.html"},{"title":"write_lines – ","text":"interface Calls interface~~write_lines~~CallsGraph interface~write_lines write_lines proc~write_lines write_lines interface~write_lines->proc~write_lines assert assert proc~write_lines->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type( string_t ), intent(in), optional :: file_name","tags":"","loc":"interface/write_lines.html"},{"title":"within_tolerance – ","text":"interface Calls interface~~within_tolerance~~CallsGraph interface~within_tolerance within_tolerance proc~within_tolerance within_tolerance interface~within_tolerance->proc~within_tolerance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function within_tolerance(self, reference, tolerance) result(in_tolerance) Implementation → Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: reference real, intent(in) :: tolerance Return Value logical Description template method with true result iff the difference in state vectors (self - reference) has a norm within tolerance\n(impure because of internal call to 'subtract' binding)\nThe existence of self procedure eliminates the need to rewrite similar code for every oracle child type.","tags":"","loc":"interface/within_tolerance.html"},{"title":"operator(.catColumns.) – ","text":"public interface operator(.catColumns.) Calls interface~~operator(.catcolumns.)~~CallsGraph interface~operator(.catcolumns.) operator(.catColumns.) interface~concatenate_columns concatenate_columns interface~operator(.catcolumns.)->interface~concatenate_columns proc~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures concatenate_columns Module Procedures private interface concatenate_columns () Arguments None","tags":"","loc":"interface/operator(.catcolumns.).html"},{"title":"operator(.catRows.) – ","text":"public interface operator(.catRows.) Calls interface~~operator(.catrows.)~~CallsGraph interface~operator(.catrows.) operator(.catRows.) interface~concatenate_rows concatenate_rows interface~operator(.catrows.)->interface~concatenate_rows proc~concatenate_rows concatenate_rows interface~concatenate_rows->proc~concatenate_rows interface~concatenate_columns concatenate_columns proc~concatenate_rows->interface~concatenate_columns proc~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures concatenate_rows Module Procedures private interface concatenate_rows () Arguments None","tags":"","loc":"interface/operator(.catrows.).html"},{"title":"operator(.columnVectors.) – ","text":"public interface operator(.columnVectors.) Calls interface~~operator(.columnvectors.)~~CallsGraph interface~operator(.columnvectors.) operator(.columnVectors.) interface~column_vectors column_vectors interface~operator(.columnvectors.)->interface~column_vectors proc~column_vectors column_vectors interface~column_vectors->proc~column_vectors assert assert proc~column_vectors->assert n n proc~column_vectors->n Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures column_vectors Module Procedures private interface column_vectors () Arguments None","tags":"","loc":"interface/operator(.columnvectors.).html"},{"title":"column_vectors – ","text":"interface Calls interface~~column_vectors~~CallsGraph interface~column_vectors column_vectors proc~column_vectors column_vectors interface~column_vectors->proc~column_vectors assert assert proc~column_vectors->assert n n proc~column_vectors->n Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~column_vectors~~CalledByGraph interface~column_vectors column_vectors interface~operator(.columnvectors.) operator(.columnVectors.) interface~operator(.columnvectors.)->interface~column_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function column_vectors(vector_field) result(array_of_3D_column_vectors) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,dimension(:,:),allocatable Description Result is array of 3D column vectors of dimension (space_dim,nx ny nz) reshaped from vector-field argument\nof dimension (nx,ny,nz,space_dim)","tags":"","loc":"interface/column_vectors.html"},{"title":"concatenate_columns – ","text":"interface Calls interface~~concatenate_columns~~CallsGraph interface~concatenate_columns concatenate_columns proc~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~concatenate_columns~~CalledByGraph interface~concatenate_columns concatenate_columns proc~concatenate_rows concatenate_rows proc~concatenate_rows->interface~concatenate_columns interface~operator(.catcolumns.) operator(.catColumns.) interface~operator(.catcolumns.)->interface~concatenate_columns interface~concatenate_rows concatenate_rows interface~concatenate_rows->proc~concatenate_rows interface~operator(.catrows.) operator(.catRows.) interface~operator(.catrows.)->interface~concatenate_rows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function concatenate_columns(a, b) result(concatenated) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:),allocatable Description Result contains the concatenation of the columns of argument a with the columns of argument b","tags":"","loc":"interface/concatenate_columns.html"},{"title":"concatenate_rows – ","text":"interface Calls interface~~concatenate_rows~~CallsGraph interface~concatenate_rows concatenate_rows proc~concatenate_rows concatenate_rows interface~concatenate_rows->proc~concatenate_rows interface~concatenate_columns concatenate_columns proc~concatenate_rows->interface~concatenate_columns proc~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~concatenate_rows~~CalledByGraph interface~concatenate_rows concatenate_rows interface~operator(.catrows.) operator(.catRows.) interface~operator(.catrows.)->interface~concatenate_rows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function concatenate_rows(a, b) result(concatenated) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:),allocatable Description Result contains the concatenation of the rows of argument a with the rows of argument b","tags":"","loc":"interface/concatenate_rows.html"},{"title":"define_partitions – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~define_partitions~~CallsGraph interface~define_partitions define_partitions proc~define_partitions define_partitions interface~define_partitions->proc~define_partitions assert assert proc~define_partitions->assert last_datum last_datum proc~define_partitions->last_datum first_datum first_datum proc~define_partitions->first_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine define_partitions(cardinality) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality Description define the range of data identification numbers owned by the executing image","tags":"","loc":"interface/define_partitions.html"},{"title":"first – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~first~~CallsGraph interface~first first proc~first first interface~first->proc~first assert assert proc~first->assert first_datum first_datum proc~first->first_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function first(image_number) result(first_index) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Description the result is the first identification number owned by the executing image","tags":"","loc":"interface/first.html"},{"title":"gather_real32_1D_array – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~gather_real32_1d_array~~CallsGraph interface~gather_real32_1d_array gather_real32_1D_array proc~gather_real32_1d_array gather_real32_1D_array interface~gather_real32_1d_array->proc~gather_real32_1d_array assert assert proc~gather_real32_1d_array->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine gather_real32_1D_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 1D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real32_1d_array.html"},{"title":"gather_real32_2D_array – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~gather_real32_2d_array~~CallsGraph interface~gather_real32_2d_array gather_real32_2D_array proc~gather_real32_2d_array gather_real32_2D_array interface~gather_real32_2d_array->proc~gather_real32_2d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine gather_real32_2D_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 2D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real32_2d_array.html"},{"title":"gather_real64_1D_array – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~gather_real64_1d_array~~CallsGraph interface~gather_real64_1d_array gather_real64_1D_array proc~gather_real64_1d_array gather_real64_1D_array interface~gather_real64_1d_array->proc~gather_real64_1d_array assert assert proc~gather_real64_1d_array->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine gather_real64_1D_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 1D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real64_1d_array.html"},{"title":"gather_real64_2D_array – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~gather_real64_2d_array~~CallsGraph interface~gather_real64_2d_array gather_real64_2D_array proc~gather_real64_2d_array gather_real64_2D_array interface~gather_real64_2d_array->proc~gather_real64_2d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine gather_real64_2D_array(a, result_image, dim) Implementation → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Description Gather the elements of an 2D array distributed along dimension dim onto result_image","tags":"","loc":"interface/gather_real64_2d_array.html"},{"title":"last – ","text":"interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. Calls interface~~last~~CallsGraph interface~last last proc~last last interface~last->proc~last assert assert proc~last->assert last_datum last_datum proc~last->last_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function last(image_number) result(last_index) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Description the result is the last identification number owned by the executing image","tags":"","loc":"interface/last.html"},{"title":"base_name – ","text":"interface Calls interface~~base_name~~CallsGraph interface~base_name base_name proc~base_name base_name interface~base_name->proc~base_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public pure module module function base_name(file_name) result(base) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable Description result contains all characters in file_name before the first dot (.)","tags":"","loc":"interface/base_name.html"},{"title":"file_extension – ","text":"interface Calls interface~~file_extension~~CallsGraph interface~file_extension file_extension proc~file_extension file_extension interface~file_extension->proc~file_extension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public pure module module function file_extension(file_name) result(extension) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable Description result contains all characters in file_name after the first dot (.)","tags":"","loc":"interface/file_extension.html"},{"title":"string – ","text":"public interface string Calls interface~~string~~CallsGraph interface~string string interface~integer_to_string integer_to_string interface~string->interface~integer_to_string proc~integer_to_string integer_to_string interface~integer_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures integer_to_string Module Procedures private interface integer_to_string () Arguments None","tags":"","loc":"interface/string.html"},{"title":"integer_to_string – ","text":"interface Calls interface~~integer_to_string~~CallsGraph interface~integer_to_string integer_to_string proc~integer_to_string integer_to_string interface~integer_to_string->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~integer_to_string~~CalledByGraph interface~integer_to_string integer_to_string interface~string string interface~string->interface~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function integer_to_string(integer_value) result(characters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),allocatable","tags":"","loc":"interface/integer_to_string.html"},{"title":"mark_as_defined – ","text":"interface Calls interface~~mark_as_defined~~CallsGraph interface~mark_as_defined mark_as_defined proc~mark_as_defined mark_as_defined interface~mark_as_defined->proc~mark_as_defined Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine mark_as_defined(self) Implementation → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: self Description Mark the co_object as user-defined","tags":"","loc":"interface/mark_as_defined.html"},{"title":"user_defined – ","text":"interface Calls interface~~user_defined~~CallsGraph interface~user_defined user_defined proc~user_defined user_defined interface~user_defined->proc~user_defined Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function user_defined(self) result(is_defined) Implementation → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: self Return Value logical Description Return a boolean result indicating whether self co_object has been initialized since its declaration","tags":"","loc":"interface/user_defined.html"},{"title":"add – ","text":"interface Calls interface~~add~~CallsGraph interface~add add proc~add add interface~add->proc~add assert assert proc~add->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Description result is the units of the sum of two dimensional quantities; includes operand consistency check","tags":"","loc":"interface/add.html"},{"title":"assign_units – ","text":"interface Calls interface~~assign_units~~CallsGraph interface~assign_units assign_units proc~assign_units assign_units interface~assign_units->proc~assign_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine assign_units(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: lhs class( units ), intent(in) :: rhs Description copy units information","tags":"","loc":"interface/assign_units.html"},{"title":"divide – ","text":"interface Calls interface~~divide~~CallsGraph interface~divide divide proc~divide divide interface~divide->proc~divide assert assert proc~divide->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function divide(numerator, denominator) result(ratio) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: numerator class( units ), intent(in) :: denominator Return Value type( units ) Description result is the units of the ratio of two dimensional quantities; includes units-sysetm consistency check","tags":"","loc":"interface/divide.html"},{"title":"get_system – ","text":"interface Calls interface~~get_system~~CallsGraph interface~get_system get_system proc~get_system get_system interface~get_system->proc~get_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function get_system(this) result(system_of_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer Description result is enumerated value designating units system","tags":"","loc":"interface/get_system.html"},{"title":"get_units – ","text":"interface Calls interface~~get_units~~CallsGraph interface~get_units get_units proc~get_units get_units interface~get_units->proc~get_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function get_units(this) result(exponents) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer(num_fundamental) Description result holds the exponents of each unit in the argument (most useful when the actual argument is an expression)","tags":"","loc":"interface/get_units.html"},{"title":"has_density_units – ","text":"interface Calls interface~~has_density_units~~CallsGraph interface~has_density_units has_density_units proc~has_density_units has_density_units interface~has_density_units->proc~has_density_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_density_units(this) result(density_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match kilograms (kg/m&#94;3)","tags":"","loc":"interface/has_density_units.html"},{"title":"has_energy_units – ","text":"interface Calls interface~~has_energy_units~~CallsGraph interface~has_energy_units has_energy_units proc~has_energy_units has_energy_units interface~has_energy_units->proc~has_energy_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_energy_units(this) result(energy_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match joules (J)","tags":"","loc":"interface/has_energy_units.html"},{"title":"has_length_units – ","text":"interface Calls interface~~has_length_units~~CallsGraph interface~has_length_units has_length_units proc~has_length_units has_length_units interface~has_length_units->proc~has_length_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_length_units(this) result(length_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match meters (m)","tags":"","loc":"interface/has_length_units.html"},{"title":"has_mass_units – ","text":"interface Calls interface~~has_mass_units~~CallsGraph interface~has_mass_units has_mass_units proc~has_mass_units has_mass_units interface~has_mass_units->proc~has_mass_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_mass_units(this) result(mass_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match kilograms (kg)","tags":"","loc":"interface/has_mass_units.html"},{"title":"has_power_units – ","text":"interface Calls interface~~has_power_units~~CallsGraph interface~has_power_units has_power_units proc~has_power_units has_power_units interface~has_power_units->proc~has_power_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_power_units(this) result(power_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match Watts (W)","tags":"","loc":"interface/has_power_units.html"},{"title":"has_specific_energy_units – ","text":"interface Calls interface~~has_specific_energy_units~~CallsGraph interface~has_specific_energy_units has_specific_energy_units proc~has_specific_energy_units has_specific_energy_units interface~has_specific_energy_units->proc~has_specific_energy_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_specific_energy_units(this) result(specific_energy_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match Joules per kilogram (J/kg)","tags":"","loc":"interface/has_specific_energy_units.html"},{"title":"has_stress_units – ","text":"interface Calls interface~~has_stress_units~~CallsGraph interface~has_stress_units has_stress_units proc~has_stress_units has_stress_units interface~has_stress_units->proc~has_stress_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_stress_units(this) result(stress_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match Newtons per square meter (N/m&#94;2)","tags":"","loc":"interface/has_stress_units.html"},{"title":"has_temperature_units – ","text":"interface Calls interface~~has_temperature_units~~CallsGraph interface~has_temperature_units has_temperature_units proc~has_temperature_units has_temperature_units interface~has_temperature_units->proc~has_temperature_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_temperature_units(this) result(temperature_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match degrees Kelvin (K)","tags":"","loc":"interface/has_temperature_units.html"},{"title":"has_time_units – ","text":"interface Calls interface~~has_time_units~~CallsGraph interface~has_time_units has_time_units proc~has_time_units has_time_units interface~has_time_units->proc~has_time_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_time_units(this) result(time_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match seconds (s)","tags":"","loc":"interface/has_time_units.html"},{"title":"has_velocity_units – ","text":"interface Calls interface~~has_velocity_units~~CallsGraph interface~has_velocity_units has_velocity_units proc~has_velocity_units has_velocity_units interface~has_velocity_units->proc~has_velocity_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function has_velocity_units(this) result(velocity_units) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if units match meters/second&#94;2 (m/s&#94;2)","tags":"","loc":"interface/has_velocity_units.html"},{"title":"integer_power – ","text":"interface Calls interface~~integer_power~~CallsGraph interface~integer_power integer_power proc~integer_power integer_power interface~integer_power->proc~integer_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function integer_power(this, exponent_) result(this_raised) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this integer, intent(in) :: exponent_ Return Value type( units ) Description result has units of the opearand raised to the power \"exponent_\"","tags":"","loc":"interface/integer_power.html"},{"title":"is_dimensionless – ","text":"interface Calls interface~~is_dimensionless~~CallsGraph interface~is_dimensionless is_dimensionless proc~is_dimensionless is_dimensionless interface~is_dimensionless->proc~is_dimensionless Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function is_dimensionless(this) result(nondimensional) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Description Return true if all units exponents are zero; false otherwise.","tags":"","loc":"interface/is_dimensionless.html"},{"title":"multiply – ","text":"interface Calls interface~~multiply~~CallsGraph interface~multiply multiply proc~multiply multiply interface~multiply->proc~multiply assert assert proc~multiply->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function multiply(lhs, rhs) result(product_) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Description result is the units of the product of two dimensional quantities; includes units-system consistency check","tags":"","loc":"interface/multiply.html"},{"title":"negate – ","text":"interface Calls interface~~negate~~CallsGraph interface~negate negate proc~negate negate interface~negate->proc~negate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function negate(this) result(negative_this) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value type( units ) Description result is the units of the negative of a dimensional quantities","tags":"","loc":"interface/negate.html"},{"title":"real_power – ","text":"interface Calls interface~~real_power~~CallsGraph interface~real_power real_power proc~real_power real_power interface~real_power->proc~real_power assert assert proc~real_power->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function real_power(this, exponent_) result(this_raised) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this real, intent(in) :: exponent_ Return Value type( units ) Description result is the units of the operand raised to the power \"exponent_\"; includes check that operand is dimensionless","tags":"","loc":"interface/real_power.html"},{"title":"set_units – ","text":"interface Calls interface~~set_units~~CallsGraph interface~set_units set_units proc~set_units set_units interface~set_units->proc~set_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine set_units(this, exponents, system) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: this integer, intent(in) :: exponents (num_fundamental) integer, intent(in) :: system Description define units","tags":"","loc":"interface/set_units.html"},{"title":"subtract – ","text":"interface Calls interface~~subtract~~CallsGraph interface~subtract subtract proc~subtract subtract interface~subtract->proc~subtract assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private impure elemental module module function subtract(lhs, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Description result is the units of the difference of two dimensional quantities; includes operand consistency check","tags":"","loc":"interface/subtract.html"},{"title":"co_all – ","text":"interface Calls interface~~co_all~~CallsGraph interface~co_all co_all proc~co_all co_all interface~co_all->proc~co_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public module module subroutine co_all(boolean) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean Description If any image in a team calls this subroutine, then every image in the \nthe same team must call this subroutine.  This subroutine sets the\n\"boolean\" argument .true. if it is true in all participating images\nupon entry and .false. otherwise.","tags":"","loc":"interface/co_all.html"},{"title":"array_of_strings – ","text":"interface Calls interface~~array_of_strings~~CallsGraph interface~array_of_strings array_of_strings proc~array_of_strings array_of_strings interface~array_of_strings->proc~array_of_strings interface~string_t string_t proc~array_of_strings->interface~string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public pure module module function array_of_strings(delimited_strings, delimiter) result(strings_array) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: delimited_strings character(len=*), intent(in) :: delimiter Return Value type( string_t ),allocatable,(:)","tags":"","loc":"interface/array_of_strings.html"},{"title":"string_t – ","text":"public interface string_t Called by interface~~string_t~~CalledByGraph interface~string_t string_t proc~array_of_strings array_of_strings proc~array_of_strings->interface~string_t interface~array_of_strings array_of_strings interface~array_of_strings->proc~array_of_strings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions construct Functions private elemental module function construct(string) result(new_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( string_t )","tags":"","loc":"interface/string_t.html"},{"title":"is_allocated – ","text":"interface Calls interface~~is_allocated~~CallsGraph interface~is_allocated is_allocated proc~is_allocated is_allocated interface~is_allocated->proc~is_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private elemental module module function is_allocated(self) result(string_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/is_allocated.html"},{"title":"string – ","text":"interface Calls interface~~string~2~~CallsGraph interface~string~2 string proc~string string interface~string~2->proc~string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function string(self) result(raw_string) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value character(len=:),allocatable","tags":"","loc":"interface/string~2.html"},{"title":"mark_as_defined – ","text":"interface Calls interface~~mark_as_defined~2~~CallsGraph interface~mark_as_defined~2 mark_as_defined proc~mark_as_defined~2 mark_as_defined interface~mark_as_defined~2->proc~mark_as_defined~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine mark_as_defined(self) Implementation → Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self Description Mark the object as user-defined","tags":"","loc":"interface/mark_as_defined~2.html"},{"title":"user_defined – ","text":"interface Calls interface~~user_defined~2~~CallsGraph interface~user_defined~2 user_defined proc~user_defined~2 user_defined interface~user_defined~2->proc~user_defined~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function user_defined(self) result(is_defined) Implementation → Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical Description Return a boolean result indicating whether self object has been initialized since its declaration","tags":"","loc":"interface/user_defined~2.html"},{"title":"report – ","text":"interface Calls interface~~report~~CallsGraph interface~report report proc~report report interface~report->proc~report test_results test_results proc~report->test_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine report(test, passes, tests) Implementation → Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: test integer, intent(inout) :: passes integer, intent(inout) :: tests Description Print the test results and increment the tallies of passing tests and total tests","tags":"","loc":"interface/report.html"},{"title":"co_all – ","text":"module procedure co_all module module subroutine co_all(boolean) Interface → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean Called by proc~~co_all~~CalledByGraph proc~co_all co_all interface~co_all co_all interface~co_all->proc~co_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/co_all.html"},{"title":"mark_as_defined – ","text":"module procedure mark_as_defined pure module module subroutine mark_as_defined(self) Interface → Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self Called by proc~~mark_as_defined~2~~CalledByGraph proc~mark_as_defined~2 mark_as_defined interface~mark_as_defined~2 mark_as_defined interface~mark_as_defined~2->proc~mark_as_defined~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mark_as_defined~2.html"},{"title":"user_defined – ","text":"module procedure user_defined pure module module function user_defined(self) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical Called by proc~~user_defined~2~~CalledByGraph proc~user_defined~2 user_defined interface~user_defined~2 user_defined interface~user_defined~2->proc~user_defined~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/user_defined~2.html"},{"title":"construct – ","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct.html"},{"title":"lines – ","text":"module procedure lines pure module module function lines(self) result(my_lines) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type( string_t ),allocatable,(:) Called by proc~~lines~~CalledByGraph proc~lines lines interface~lines lines interface~lines->proc~lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lines.html"},{"title":"read_lines – ","text":"module procedure read_lines module procedure read_lines() Arguments None Calls proc~~read_lines~~CallsGraph proc~read_lines read_lines assert assert proc~read_lines->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_lines.html"},{"title":"write_lines – ","text":"module procedure write_lines impure elemental module module subroutine write_lines(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type( string_t ), intent(in), optional :: file_name Calls proc~~write_lines~~CallsGraph proc~write_lines write_lines assert assert proc~write_lines->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_lines~~CalledByGraph proc~write_lines write_lines interface~write_lines write_lines interface~write_lines->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_lines.html"},{"title":"add – ","text":"module procedure add impure elemental module module function add(lhs, rhs) result(total) Interface → Require consistent operand units Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Calls proc~~add~~CallsGraph proc~add add assert assert proc~add->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add~~CalledByGraph proc~add add interface~add add interface~add->proc~add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/add.html"},{"title":"assign_units – ","text":"module procedure assign_units pure module module subroutine assign_units(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: lhs class( units ), intent(in) :: rhs Called by proc~~assign_units~~CalledByGraph proc~assign_units assign_units interface~assign_units assign_units interface~assign_units->proc~assign_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assign_units.html"},{"title":"divide – ","text":"module procedure divide elemental module module function divide(numerator, denominator) result(ratio) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: numerator class( units ), intent(in) :: denominator Return Value type( units ) Calls proc~~divide~~CallsGraph proc~divide divide assert assert proc~divide->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~divide~~CalledByGraph proc~divide divide interface~divide divide interface~divide->proc~divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/divide.html"},{"title":"get_system – ","text":"module procedure get_system impure elemental module module function get_system(this) result(system_of_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer Called by proc~~get_system~~CalledByGraph proc~get_system get_system interface~get_system get_system interface~get_system->proc~get_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_system.html"},{"title":"get_units – ","text":"module procedure get_units module module function get_units(this) result(exponents) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer(num_fundamental) Called by proc~~get_units~~CalledByGraph proc~get_units get_units interface~get_units get_units interface~get_units->proc~get_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_units.html"},{"title":"has_density_units – ","text":"module procedure has_density_units elemental module module function has_density_units(this) result(density_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_density_units~~CalledByGraph proc~has_density_units has_density_units interface~has_density_units has_density_units interface~has_density_units->proc~has_density_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_density_units.html"},{"title":"has_energy_units – ","text":"module procedure has_energy_units elemental module module function has_energy_units(this) result(energy_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_energy_units~~CalledByGraph proc~has_energy_units has_energy_units interface~has_energy_units has_energy_units interface~has_energy_units->proc~has_energy_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_energy_units.html"},{"title":"has_length_units – ","text":"module procedure has_length_units elemental module module function has_length_units(this) result(length_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_length_units~~CalledByGraph proc~has_length_units has_length_units interface~has_length_units has_length_units interface~has_length_units->proc~has_length_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_length_units.html"},{"title":"has_mass_units – ","text":"module procedure has_mass_units elemental module module function has_mass_units(this) result(mass_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_mass_units~~CalledByGraph proc~has_mass_units has_mass_units interface~has_mass_units has_mass_units interface~has_mass_units->proc~has_mass_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_mass_units.html"},{"title":"has_power_units – ","text":"module procedure has_power_units elemental module module function has_power_units(this) result(power_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_power_units~~CalledByGraph proc~has_power_units has_power_units interface~has_power_units has_power_units interface~has_power_units->proc~has_power_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_power_units.html"},{"title":"has_specific_energy_units – ","text":"module procedure has_specific_energy_units elemental module module function has_specific_energy_units(this) result(specific_energy_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_specific_energy_units~~CalledByGraph proc~has_specific_energy_units has_specific_energy_units interface~has_specific_energy_units has_specific_energy_units interface~has_specific_energy_units->proc~has_specific_energy_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_specific_energy_units.html"},{"title":"has_stress_units – ","text":"module procedure has_stress_units elemental module module function has_stress_units(this) result(stress_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_stress_units~~CalledByGraph proc~has_stress_units has_stress_units interface~has_stress_units has_stress_units interface~has_stress_units->proc~has_stress_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_stress_units.html"},{"title":"has_temperature_units – ","text":"module procedure has_temperature_units elemental module module function has_temperature_units(this) result(temperature_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_temperature_units~~CalledByGraph proc~has_temperature_units has_temperature_units interface~has_temperature_units has_temperature_units interface~has_temperature_units->proc~has_temperature_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_temperature_units.html"},{"title":"has_time_units – ","text":"module procedure has_time_units elemental module module function has_time_units(this) result(time_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_time_units~~CalledByGraph proc~has_time_units has_time_units interface~has_time_units has_time_units interface~has_time_units->proc~has_time_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_time_units.html"},{"title":"has_velocity_units – ","text":"module procedure has_velocity_units elemental module module function has_velocity_units(this) result(velocity_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~has_velocity_units~~CalledByGraph proc~has_velocity_units has_velocity_units interface~has_velocity_units has_velocity_units interface~has_velocity_units->proc~has_velocity_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/has_velocity_units.html"},{"title":"integer_power – ","text":"module procedure integer_power impure elemental module module function integer_power(this, exponent_) result(this_raised) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this integer, intent(in) :: exponent_ Return Value type( units ) Called by proc~~integer_power~~CalledByGraph proc~integer_power integer_power interface~integer_power integer_power interface~integer_power->proc~integer_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/integer_power.html"},{"title":"is_dimensionless – ","text":"module procedure is_dimensionless elemental module module function is_dimensionless(this) result(nondimensional) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical Called by proc~~is_dimensionless~~CalledByGraph proc~is_dimensionless is_dimensionless interface~is_dimensionless is_dimensionless interface~is_dimensionless->proc~is_dimensionless Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_dimensionless.html"},{"title":"multiply – ","text":"module procedure multiply elemental module module function multiply(lhs, rhs) result(product_) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Calls proc~~multiply~~CallsGraph proc~multiply multiply assert assert proc~multiply->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multiply~~CalledByGraph proc~multiply multiply interface~multiply multiply interface~multiply->proc~multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/multiply.html"},{"title":"negate – ","text":"module procedure negate elemental module module function negate(this) result(negative_this) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value type( units ) Called by proc~~negate~~CalledByGraph proc~negate negate interface~negate negate interface~negate->proc~negate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/negate.html"},{"title":"real_power – ","text":"module procedure real_power impure elemental module module function real_power(this, exponent_) result(this_raised) Interface → Require dimensionless operand => result is default-initialized as dimensionless Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this real, intent(in) :: exponent_ Return Value type( units ) Calls proc~~real_power~~CallsGraph proc~real_power real_power assert assert proc~real_power->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~real_power~~CalledByGraph proc~real_power real_power interface~real_power real_power interface~real_power->proc~real_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/real_power.html"},{"title":"set_units – ","text":"module procedure set_units pure module module subroutine set_units(this, exponents, system) Interface → define units exponents Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: this integer, intent(in) :: exponents (num_fundamental) integer, intent(in) :: system Called by proc~~set_units~~CalledByGraph proc~set_units set_units interface~set_units set_units interface~set_units->proc~set_units Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_units.html"},{"title":"subtract – ","text":"module procedure subtract impure elemental module module function subtract(lhs, rhs) result(difference) Interface → Require consistent operand units Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Calls proc~~subtract~~CallsGraph proc~subtract subtract assert assert proc~subtract->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subtract~~CalledByGraph proc~subtract subtract interface~subtract subtract interface~subtract->proc~subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"column_vectors – ","text":"module procedure column_vectors pure module module function column_vectors(vector_field) result(array_of_3D_column_vectors) Interface → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,dimension(:,:),allocatable Calls proc~~column_vectors~~CallsGraph proc~column_vectors column_vectors assert assert proc~column_vectors->assert n n proc~column_vectors->n Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~column_vectors~~CalledByGraph proc~column_vectors column_vectors interface~column_vectors column_vectors interface~column_vectors->proc~column_vectors interface~operator(.columnvectors.) operator(.columnVectors.) interface~operator(.columnvectors.)->interface~column_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/column_vectors.html"},{"title":"concatenate_columns – ","text":"module procedure concatenate_columns pure module module function concatenate_columns(a, b) result(concatenated) Interface → Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array\nelement references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler\nto order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape\nis likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance\nbottleneck, try replacing this implementation with element-by-element copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:),allocatable Calls proc~~concatenate_columns~~CallsGraph proc~concatenate_columns concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~concatenate_columns~~CalledByGraph proc~concatenate_columns concatenate_columns interface~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns proc~concatenate_rows concatenate_rows proc~concatenate_rows->interface~concatenate_columns interface~operator(.catcolumns.) operator(.catColumns.) interface~operator(.catcolumns.)->interface~concatenate_columns interface~concatenate_rows concatenate_rows interface~concatenate_rows->proc~concatenate_rows interface~operator(.catrows.) operator(.catRows.) interface~operator(.catrows.)->interface~concatenate_rows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/concatenate_columns.html"},{"title":"concatenate_rows – ","text":"module procedure concatenate_rows pure module module function concatenate_rows(a, b) result(concatenated) Interface → For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries.\nIf this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element\ncopying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:),allocatable Calls proc~~concatenate_rows~~CallsGraph proc~concatenate_rows concatenate_rows interface~concatenate_columns concatenate_columns proc~concatenate_rows->interface~concatenate_columns proc~concatenate_columns concatenate_columns interface~concatenate_columns->proc~concatenate_columns assert assert proc~concatenate_columns->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~concatenate_rows~~CalledByGraph proc~concatenate_rows concatenate_rows interface~concatenate_rows concatenate_rows interface~concatenate_rows->proc~concatenate_rows interface~operator(.catrows.) operator(.catRows.) interface~operator(.catrows.)->interface~concatenate_rows Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/concatenate_rows.html"},{"title":"define_partitions – ","text":"module procedure define_partitions module module subroutine define_partitions(cardinality) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality Calls proc~~define_partitions~~CallsGraph proc~define_partitions define_partitions assert assert proc~define_partitions->assert last_datum last_datum proc~define_partitions->last_datum first_datum first_datum proc~define_partitions->first_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~define_partitions~~CalledByGraph proc~define_partitions define_partitions interface~define_partitions define_partitions interface~define_partitions->proc~define_partitions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/define_partitions.html"},{"title":"first – ","text":"module procedure first pure module module function first(image_number) result(first_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Calls proc~~first~~CallsGraph proc~first first assert assert proc~first->assert first_datum first_datum proc~first->first_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~first~~CalledByGraph proc~first first interface~first first interface~first->proc~first Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/first.html"},{"title":"gather_real32_1D_array – ","text":"module procedure gather_real32_1D_array module module subroutine gather_real32_1D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Calls proc~~gather_real32_1d_array~~CallsGraph proc~gather_real32_1d_array gather_real32_1D_array assert assert proc~gather_real32_1d_array->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gather_real32_1d_array~~CalledByGraph proc~gather_real32_1d_array gather_real32_1D_array interface~gather_real32_1d_array gather_real32_1D_array interface~gather_real32_1d_array->proc~gather_real32_1d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/gather_real32_1d_array.html"},{"title":"gather_real32_2D_array – ","text":"module procedure gather_real32_2D_array module module subroutine gather_real32_2D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Called by proc~~gather_real32_2d_array~~CalledByGraph proc~gather_real32_2d_array gather_real32_2D_array interface~gather_real32_2d_array gather_real32_2D_array interface~gather_real32_2d_array->proc~gather_real32_2d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/gather_real32_2d_array.html"},{"title":"gather_real64_1D_array – ","text":"module procedure gather_real64_1D_array module module subroutine gather_real64_1D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Calls proc~~gather_real64_1d_array~~CallsGraph proc~gather_real64_1d_array gather_real64_1D_array assert assert proc~gather_real64_1d_array->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gather_real64_1d_array~~CalledByGraph proc~gather_real64_1d_array gather_real64_1D_array interface~gather_real64_1d_array gather_real64_1D_array interface~gather_real64_1d_array->proc~gather_real64_1d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/gather_real64_1d_array.html"},{"title":"gather_real64_2D_array – ","text":"module procedure gather_real64_2D_array module module subroutine gather_real64_2D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim Called by proc~~gather_real64_2d_array~~CalledByGraph proc~gather_real64_2d_array gather_real64_2D_array interface~gather_real64_2d_array gather_real64_2D_array interface~gather_real64_2d_array->proc~gather_real64_2d_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/gather_real64_2d_array.html"},{"title":"last – ","text":"module procedure last pure module module function last(image_number) result(last_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Calls proc~~last~~CallsGraph proc~last last assert assert proc~last->assert last_datum last_datum proc~last->last_datum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~last~~CalledByGraph proc~last last interface~last last interface~last->proc~last Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/last.html"},{"title":"separated_values – ","text":"module procedure separated_values pure module module function separated_values(separator, mold) result(format_string) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: separator class(*), intent(in) :: mold (..) Return Value character(len=:),allocatable Called by proc~~separated_values~~CalledByGraph proc~separated_values separated_values interface~separated_values separated_values interface~separated_values->proc~separated_values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/separated_values.html"},{"title":"base_name – ","text":"module procedure base_name pure module module function base_name(file_name) result(base) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable Called by proc~~base_name~~CalledByGraph proc~base_name base_name interface~base_name base_name interface~base_name->proc~base_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/base_name.html"},{"title":"file_extension – ","text":"module procedure file_extension pure module module function file_extension(file_name) result(extension) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable Called by proc~~file_extension~~CalledByGraph proc~file_extension file_extension interface~file_extension file_extension interface~file_extension->proc~file_extension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/file_extension.html"},{"title":"integer_to_string – ","text":"module procedure integer_to_string pure module module function integer_to_string(integer_value) result(characters) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),allocatable Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string interface~integer_to_string integer_to_string interface~integer_to_string->proc~integer_to_string interface~string string interface~string->interface~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/integer_to_string.html"},{"title":"array_of_strings – ","text":"module procedure array_of_strings pure module module function array_of_strings(delimited_strings, delimiter) result(strings_array) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: delimited_strings character(len=*), intent(in) :: delimiter Return Value type( string_t ),allocatable,(:) Calls proc~~array_of_strings~~CallsGraph proc~array_of_strings array_of_strings interface~string_t string_t proc~array_of_strings->interface~string_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~array_of_strings~~CalledByGraph proc~array_of_strings array_of_strings interface~array_of_strings array_of_strings interface~array_of_strings->proc~array_of_strings Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/array_of_strings.html"},{"title":"construct – ","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~2.html"},{"title":"is_allocated – ","text":"module procedure is_allocated elemental module module function is_allocated(self) result(string_allocated) Interface → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value logical Called by proc~~is_allocated~~CalledByGraph proc~is_allocated is_allocated interface~is_allocated is_allocated interface~is_allocated->proc~is_allocated Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_allocated.html"},{"title":"string – ","text":"module procedure string pure module module function string(self) result(raw_string) Interface → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value character(len=:),allocatable Called by proc~~string~~CalledByGraph proc~string string interface~string~2 string interface~string~2->proc~string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/string.html"},{"title":"report – ","text":"module procedure report module module subroutine report(test, passes, tests) Interface → Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: test integer, intent(inout) :: passes integer, intent(inout) :: tests Calls proc~~report~~CallsGraph proc~report report test_results test_results proc~report->test_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~report~~CalledByGraph proc~report report interface~report report interface~report->proc~report Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/report.html"},{"title":"argument_present – ","text":"module procedure argument_present module module function argument_present(acceptable_argument) result(found) Interface → list of acceptable arguments\nsample list: [character(len=len(longest_argument)):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS and slashes support Windows Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: acceptable_argument (:) sample list: [character(len=len( )):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS, slashes support Windows, and must be replaced\nby the longest list element (\"--benchmark\" above) Return Value logical Calls proc~~argument_present~~CallsGraph proc~argument_present argument_present acceptable_length acceptable_length proc~argument_present->acceptable_length Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~argument_present~~CalledByGraph proc~argument_present argument_present interface~argument_present argument_present interface~argument_present->proc~argument_present Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/argument_present.html"},{"title":"flag_value – ","text":"module procedure flag_value module module function flag_value(flag) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flag Return Value character(len=:),allocatable Called by proc~~flag_value~~CalledByGraph proc~flag_value flag_value interface~flag_value flag_value interface~flag_value->proc~flag_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/flag_value.html"},{"title":"mark_as_defined – ","text":"module procedure mark_as_defined pure module module subroutine mark_as_defined(self) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: self Called by proc~~mark_as_defined~~CalledByGraph proc~mark_as_defined mark_as_defined interface~mark_as_defined mark_as_defined interface~mark_as_defined->proc~mark_as_defined Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mark_as_defined.html"},{"title":"user_defined – ","text":"module procedure user_defined pure module module function user_defined(self) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: self Return Value logical Called by proc~~user_defined~~CalledByGraph proc~user_defined user_defined interface~user_defined user_defined interface~user_defined->proc~user_defined Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/user_defined.html"},{"title":"characterize – ","text":"module procedure characterize pure module module function characterize(self) result(characterization) Interface → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value character(len=:),allocatable Called by proc~~characterize~~CalledByGraph proc~characterize characterize interface~characterize characterize interface~characterize->proc~characterize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/characterize.html"},{"title":"construct – ","text":"module procedure construct module procedure construct() Arguments None Contents None","tags":"","loc":"proc/construct~3.html"},{"title":"passed – ","text":"module procedure passed elemental module module function passed(self) result(test_passed) Interface → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical Called by proc~~passed~~CalledByGraph proc~passed passed interface~passed passed interface~passed->proc~passed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/passed.html"},{"title":"within_tolerance – ","text":"module procedure within_tolerance module module function within_tolerance(self, reference, tolerance) result(in_tolerance) Interface → Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: reference real, intent(in) :: tolerance Return Value logical Called by proc~~within_tolerance~~CalledByGraph proc~within_tolerance within_tolerance interface~within_tolerance within_tolerance interface~within_tolerance->proc~within_tolerance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/within_tolerance.html"},{"title":"sourcery_m – ","text":"export all public entities from every other sourcery module Uses user_defined_collectives_m file_m test_result_m units_m object_m command_line_m co_object_m data_partition_m test_m formats_m string_m oracle_m module~~sourcery_m~~UsesGraph module~sourcery_m sourcery_m module~user_defined_collectives_m user_defined_collectives_m module~sourcery_m->module~user_defined_collectives_m module~data_partition_m data_partition_m module~sourcery_m->module~data_partition_m module~units_m units_m module~sourcery_m->module~units_m module~test_m test_m module~sourcery_m->module~test_m module~command_line_m command_line_m module~sourcery_m->module~command_line_m module~string_m string_m module~sourcery_m->module~string_m module~oracle_m oracle_m module~sourcery_m->module~oracle_m module~test_result_m test_result_m module~sourcery_m->module~test_result_m module~object_m object_m module~sourcery_m->module~object_m module~file_m file_m module~sourcery_m->module~file_m module~co_object_m co_object_m module~sourcery_m->module~co_object_m module~formats_m formats_m module~sourcery_m->module~formats_m iso_fortran_env iso_fortran_env module~data_partition_m->iso_fortran_env module~test_m->module~test_result_m module~oracle_m->module~object_m module~file_m->module~string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/sourcery_m.html"},{"title":"command_line_m – ","text":"return command line argument information Used by Descendants: command_line_s module~~command_line_m~~UsedByGraph module~command_line_m command_line_m module~sourcery_m sourcery_m module~sourcery_m->module~command_line_m module~command_line_s command_line_s module~command_line_s->module~command_line_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces argument_present flag_value Derived Types command_line_t Interfaces interface private module module function argument_present(acceptable_argument) result(found) Implementation → result is .true. only if a command-line argument matches an element of this function's argument Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: acceptable_argument (:) sample list: [character(len=len( )):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS, slashes support Windows, and must be replaced\nby the longest list element (\"--benchmark\" above) Return Value logical interface private module module function flag_value(flag) Implementation → result is the value passed adjacent to a command-line flag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flag Return Value character(len=:),allocatable Derived Types type, public :: command_line_t Type-Bound Procedures procedure, public, nopass :: argument_present procedure, public, nopass :: flag_value","tags":"","loc":"module/command_line_m.html"},{"title":"formats_m – ","text":"Useful strings for formatting print and write statements Used by Descendants: formats_s module~~formats_m~~UsedByGraph module~formats_m formats_m module~sourcery_m sourcery_m module~sourcery_m->module~formats_m module~formats_s formats_s module~formats_s->module~formats_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cscv csv Interfaces separated_values Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: cscv = \"(*('(',G0,',',G0,')',:,',')))\" comma-separated complex values character(len=*), public, parameter :: csv = \"(*(G0,:,','))\" comma-separated values Interfaces interface public pure module module function separated_values(separator, mold) result(format_string) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: separator class(*), intent(in) :: mold (..) Return Value character(len=:),allocatable","tags":"","loc":"module/formats_m.html"},{"title":"test_result_m – ","text":"Define an abstraction for describing test intentions and results Used by Descendants: test_result_s module~~test_result_m~~UsedByGraph module~test_result_m test_result_m module~sourcery_m sourcery_m module~sourcery_m->module~test_result_m module~test_m test_m module~sourcery_m->module~test_m module~test_result_s test_result_s module~test_result_s->module~test_result_m module~test_m->module~test_result_m module~test_s test_s module~test_s->module~test_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces test_result_t characterize passed Derived Types test_result_t Interfaces public interface test_result_t private elemental module function construct(description, passed) result(test_result) The result is a test_result_t object with the components defined by the dummy arguments Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: description logical, intent(in) :: passed Return Value type( test_result_t ) interface private pure module module function characterize(self) result(characterization) Implementation → The result is a character description of the test and its outcome Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value character(len=:),allocatable interface private elemental module module function passed(self) result(test_passed) Implementation → The result is a character description of the test and its outcome Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical Derived Types type, public :: test_result_t Encapsulate test descriptions and outcomes and reporting Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: description_ logical, private :: passed_ Constructor private elemental,module function construct (description, passed) The result is a test_result_t object with the components defined by the dummy arguments Type-Bound Procedures procedure, public :: characterize procedure, public :: passed","tags":"","loc":"module/test_result_m.html"},{"title":"file_m – ","text":"A representation of a file as an object Uses string_m module~~file_m~~UsesGraph module~file_m file_m module~string_m string_m module~file_m->module~string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: file_s module~~file_m~~UsedByGraph module~file_m file_m module~sourcery_m sourcery_m module~sourcery_m->module~file_m module~file_s file_s module~file_s->module~file_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces file_t lines write_lines Derived Types file_t Interfaces public interface file_t private pure module function construct(lines) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in), allocatable :: lines (:) Return Value type( file_t ) private impure elemental module function read_lines(file_name) result(file_object) Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: file_name Return Value type( file_t ) interface private pure module module function lines(self) result(my_lines) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type( string_t ),allocatable, (:) interface private impure elemental module module subroutine write_lines(self, file_name) Implementation → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type( string_t ), intent(in), optional :: file_name Derived Types type, public :: file_t Components Type Visibility Attributes Name Initial type( string_t ), private, allocatable :: lines_ (:) Constructor private pure,module function construct (lines) private impure,elemental,module function read_lines (file_name) Type-Bound Procedures procedure, public :: lines procedure, public :: write_lines","tags":"","loc":"module/file_m.html"},{"title":"oracle_m – ","text":"verify actual output against expected Uses object_m module~~oracle_m~~UsesGraph module~oracle_m oracle_m module~object_m object_m module~oracle_m->module~object_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: oracle_s module~~oracle_m~~UsedByGraph module~oracle_m oracle_m module~sourcery_m sourcery_m module~sourcery_m->module~oracle_m module~oracle_s oracle_s module~oracle_s->module~oracle_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces within_tolerance Abstract Interfaces norm_interface subtract_interface Derived Types oracle_t Interfaces interface private module module function within_tolerance(self, reference, tolerance) result(in_tolerance) Implementation → template method with true result iff the difference in state vectors (self - reference) has a norm within tolerance\n(impure because of internal call to 'subtract' binding)\nThe existence of self procedure eliminates the need to rewrite similar code for every oracle child type. Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: reference real, intent(in) :: tolerance Return Value logical Abstract Interfaces abstract interface private pure function norm_interface(self) result(norm_of_self) result is a norm of the array formed by concatenating the real components of self object Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self Return Value real abstract interface private function subtract_interface(self, rhs) result(difference) result has components corresponding to subtracting rhs's components fron self object's components Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: rhs Return Value class( oracle_t ),allocatable Derived Types type, public, abstract, extends( object_t ) :: oracle_t define procedures for testing output values against expected values Type-Bound Procedures procedure, public :: mark_as_defined procedure(norm_interface), public :: norm generic, public :: operator(-) => subtract procedure(subtract_interface), public :: subtract procedure, public :: user_defined procedure, public :: within_tolerance generic, public :: write(formatted) => write_formatted procedure(write_interface), public :: write_formatted","tags":"","loc":"module/oracle_m.html"},{"title":"array_functions_m – ","text":"Functionally pure array utilities\nBecause the Fortran standard requires that operator dummy arguments have the intent(in) attribute\nexposing only the operator and not the function names communicates more information in the\npublic interface and in code using this interface. Used by Descendants: array_functions_s module~~array_functions_m~~UsedByGraph module~array_functions_m array_functions_m module~array_functions_s array_functions_s module~array_functions_s->module~array_functions_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces operator(.catColumns.) operator(.catRows.) operator(.columnVectors.) column_vectors concatenate_columns concatenate_rows Interfaces public interface operator(.catColumns.) private interface concatenate_columns () Arguments None public interface operator(.catRows.) private interface concatenate_rows () Arguments None public interface operator(.columnVectors.) private interface column_vectors () Arguments None interface private pure module module function column_vectors(vector_field) result(array_of_3D_column_vectors) Implementation → Result is array of 3D column vectors of dimension (space_dim,nx ny nz) reshaped from vector-field argument\nof dimension (nx,ny,nz,space_dim) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,dimension(:,:), allocatable interface private pure module module function concatenate_columns(a, b) result(concatenated) Implementation → Result contains the concatenation of the columns of argument a with the columns of argument b Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:), allocatable interface private pure module module function concatenate_rows(a, b) result(concatenated) Implementation → Result contains the concatenation of the rows of argument a with the rows of argument b Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:), allocatable","tags":"","loc":"module/array_functions_m.html"},{"title":"data_partition_m – ","text":"distribute data identification numbers across images such that the number of\nitems differs by at most 1 between any two images. Uses iso_fortran_env module~~data_partition_m~~UsesGraph module~data_partition_m data_partition_m iso_fortran_env iso_fortran_env module~data_partition_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: data_partition_s module~~data_partition_m~~UsedByGraph module~data_partition_m data_partition_m module~sourcery_m sourcery_m module~sourcery_m->module~data_partition_m module~data_partition_s data_partition_s module~data_partition_s->module~data_partition_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables first_datum last_datum Interfaces define_partitions first gather_real32_1D_array gather_real32_2D_array gather_real64_1D_array gather_real64_2D_array last Derived Types data_partition_t Variables Type Visibility Attributes Name Initial integer, private, allocatable :: first_datum (:) integer, private, allocatable :: last_datum (:) Interfaces interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine define_partitions(cardinality) Implementation → define the range of data identification numbers owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private pure module module function first(image_number) result(first_index) Implementation → the result is the first identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real32_1D_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real32_2D_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real64_1D_array(a, result_image, dim) Implementation → Gather the elements of an 1D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private module module subroutine gather_real64_2D_array(a, result_image, dim) Implementation → Gather the elements of an 2D array distributed along dimension dim onto result_image Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim interface Gathers are inherently expensive and are best used either\n1. Near the beginning/end of execution to amortize costs across an entire run or\n2. Temporarily while developing/debugging code. private pure module module function last(image_number) result(last_index) Implementation → the result is the last identification number owned by the executing image Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer Derived Types type, public :: data_partition_t encapsulate a description of the data subset the executing image owns Type-Bound Procedures procedure, public, nopass :: define_partitions procedure, public, nopass :: first generic, public :: gather => gather_real32_2D_array, gather_real64_2D_array, gather_real32_1D_array, gather_real64_1D_array procedure, public, nopass :: last procedure, private, nopass :: gather_real32_1D_array procedure, private, nopass :: gather_real32_2D_array procedure, private, nopass :: gather_real64_1D_array procedure, private, nopass :: gather_real64_2D_array","tags":"","loc":"module/data_partition_m.html"},{"title":"string_functions_m – ","text":"Used by Descendants: string_functions_s module~~string_functions_m~~UsedByGraph module~string_functions_m string_functions_m module~string_functions_s string_functions_s module~string_functions_s->module~string_functions_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces base_name file_extension string integer_to_string Interfaces interface public pure module module function base_name(file_name) result(base) Implementation → result contains all characters in file_name before the first dot (.) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable interface public pure module module function file_extension(file_name) result(extension) Implementation → result contains all characters in file_name after the first dot (.) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable public interface string private interface integer_to_string () Arguments None interface private pure module module function integer_to_string(integer_value) result(characters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),allocatable","tags":"","loc":"module/string_functions_m.html"},{"title":"co_object_m – ","text":"Used by Descendants: co_object_s module~~co_object_m~~UsedByGraph module~co_object_m co_object_m module~sourcery_m sourcery_m module~sourcery_m->module~co_object_m module~co_object_s co_object_s module~co_object_s->module~co_object_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces mark_as_defined user_defined Derived Types co_object Interfaces interface private pure module module subroutine mark_as_defined(self) Implementation → Mark the co_object as user-defined Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: self interface private pure module module function user_defined(self) result(is_defined) Implementation → Return a boolean result indicating whether self co_object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: self Return Value logical Derived Types type, public, abstract :: co_object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined logical, private, allocatable :: facilitate_type_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined procedure, public :: user_defined","tags":"","loc":"module/co_object_m.html"},{"title":"units_m – ","text":"Define SI and British units of measurement and associated arithmetic operators Used by Descendants: units_s module~~units_m~~UsedByGraph module~units_m units_m module~sourcery_m sourcery_m module~sourcery_m->module~units_m module~units_s units_s module~units_s->module~units_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables British_units_names SI_units_names num_fundamental units_system_names num_systems Enumerations Interfaces add assign_units divide get_system get_units has_density_units has_energy_units has_length_units has_mass_units has_power_units has_specific_energy_units has_stress_units has_temperature_units has_time_units has_velocity_units integer_power is_dimensionless multiply negate real_power set_units subtract Derived Types units Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: British_units_names (num_fundamental) = [character(len=len(\"sec\"))::\"R\", \"ft\", \"lbm\", \"sec\"] character(len=*), public, parameter :: SI_units_names (num_fundamental) = [character(len=len(\"sec\"))::\"K\", \"m\", \"kg\", \"sec\"] integer, public, parameter :: num_fundamental = 4 character(len=*), public, parameter :: units_system_names (num_systems) = [character(len=len(\"British\"))::\"SI\", \"British\"] integer, private, parameter :: num_systems = 2 Enumerations enum, bind(c) Enumerators enumerator :: K = 1 enumerator :: m = 2 enumerator :: kg = 3 enumerator :: sec = 4 enumerator :: R = 1 enumerator :: ft = 2 enumerator :: lbm = 3 enumerator :: dimensionless = 0 enumerator :: SI = 1 enumerator :: British = 2 Description Enumerate the fundamental units for dimensional units quantities\n(meters, kilograms, seconds, and degrees Kelvin) Interfaces interface private impure elemental module module function add(lhs, rhs) result(total) Implementation → result is the units of the sum of two dimensional quantities; includes operand consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) interface private pure module module subroutine assign_units(lhs, rhs) Implementation → copy units information Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: lhs class( units ), intent(in) :: rhs interface private elemental module module function divide(numerator, denominator) result(ratio) Implementation → result is the units of the ratio of two dimensional quantities; includes units-sysetm consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: numerator class( units ), intent(in) :: denominator Return Value type( units ) interface private impure elemental module module function get_system(this) result(system_of_units) Implementation → result is enumerated value designating units system Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer interface private module module function get_units(this) result(exponents) Implementation → result holds the exponents of each unit in the argument (most useful when the actual argument is an expression) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer(num_fundamental) interface private elemental module module function has_density_units(this) result(density_units) Implementation → Return true if units match kilograms (kg/m&#94;3) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_energy_units(this) result(energy_units) Implementation → Return true if units match joules (J) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_length_units(this) result(length_units) Implementation → Return true if units match meters (m) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_mass_units(this) result(mass_units) Implementation → Return true if units match kilograms (kg) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_power_units(this) result(power_units) Implementation → Return true if units match Watts (W) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_specific_energy_units(this) result(specific_energy_units) Implementation → Return true if units match Joules per kilogram (J/kg) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_stress_units(this) result(stress_units) Implementation → Return true if units match Newtons per square meter (N/m&#94;2) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_temperature_units(this) result(temperature_units) Implementation → Return true if units match degrees Kelvin (K) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_time_units(this) result(time_units) Implementation → Return true if units match seconds (s) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function has_velocity_units(this) result(velocity_units) Implementation → Return true if units match meters/second&#94;2 (m/s&#94;2) Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private impure elemental module module function integer_power(this, exponent_) result(this_raised) Implementation → result has units of the opearand raised to the power \"exponent_\" Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this integer, intent(in) :: exponent_ Return Value type( units ) interface private elemental module module function is_dimensionless(this) result(nondimensional) Implementation → Return true if all units exponents are zero; false otherwise. Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical interface private elemental module module function multiply(lhs, rhs) result(product_) Implementation → result is the units of the product of two dimensional quantities; includes units-system consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) interface private elemental module module function negate(this) result(negative_this) Implementation → result is the units of the negative of a dimensional quantities Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value type( units ) interface private impure elemental module module function real_power(this, exponent_) result(this_raised) Implementation → result is the units of the operand raised to the power \"exponent_\"; includes check that operand is dimensionless Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this real, intent(in) :: exponent_ Return Value type( units ) interface private pure module module subroutine set_units(this, exponents, system) Implementation → define units Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: this integer, intent(in) :: exponents (num_fundamental) integer, intent(in) :: system interface private impure elemental module module function subtract(lhs, rhs) result(difference) Implementation → result is the units of the difference of two dimensional quantities; includes operand consistency check Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) Derived Types type, public :: units Morfeus universal base type for all units Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: description integer, private :: exponents_ (num_fundamental) = dimensionless Store the exponents for fundamental units integer, private :: system = dimensionless Default to SI units Type-Bound Procedures procedure, public :: add procedure, public :: assign_units generic, public :: assignment(=) => assign_units procedure, public :: divide procedure, public :: get_system procedure, public :: get_units procedure, public :: has_density_units procedure, public :: has_energy_units procedure, public :: has_length_units procedure, public :: has_mass_units procedure, public :: has_power_units procedure, public :: has_specific_energy_units procedure, public :: has_stress_units procedure, public :: has_temperature_units procedure, public :: has_time_units procedure, public :: has_velocity_units procedure, public :: integer_power procedure, public :: is_dimensionless procedure, public :: multiply procedure, public :: negate generic, public :: operator(*) => multiply generic, public :: operator(**) => integer_power, real_power generic, public :: operator(+) => add generic, public :: operator(-) => subtract, negate generic, public :: operator(/) => divide procedure, public :: real_power procedure, public :: set_units procedure, public :: subtract","tags":"","loc":"module/units_m.html"},{"title":"user_defined_collectives_m – ","text":"This module contains user-defined collective subroutines. Used by Descendants: user_defined_collectives_s module~~user_defined_collectives_m~~UsedByGraph module~user_defined_collectives_m user_defined_collectives_m module~sourcery_m sourcery_m module~sourcery_m->module~user_defined_collectives_m module~user_defined_collectives_s user_defined_collectives_s module~user_defined_collectives_s->module~user_defined_collectives_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces co_all Interfaces interface public module module subroutine co_all(boolean) Implementation → If any image in a team calls this subroutine, then every image in the \nthe same team must call this subroutine.  This subroutine sets the\n\"boolean\" argument .true. if it is true in all participating images\nupon entry and .false. otherwise. Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean","tags":"","loc":"module/user_defined_collectives_m.html"},{"title":"string_m – ","text":"Used by Descendants: string_s module~~string_m~~UsedByGraph module~string_m string_m module~file_m file_m module~file_m->module~string_m module~string_s string_s module~string_s->module~string_m module~sourcery_m sourcery_m module~sourcery_m->module~string_m module~sourcery_m->module~file_m module~file_s file_s module~file_s->module~file_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces array_of_strings string_t is_allocated string Derived Types string_t Interfaces interface public pure module module function array_of_strings(delimited_strings, delimiter) result(strings_array) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: delimited_strings character(len=*), intent(in) :: delimiter Return Value type( string_t ),allocatable, (:) public interface string_t private elemental module function construct(string) result(new_string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( string_t ) interface private elemental module module function is_allocated(self) result(string_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value logical interface private pure module module function string(self) result(raw_string) Implementation → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value character(len=:),allocatable Derived Types type, public :: string_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: string_ Constructor private elemental,module function construct (string) Type-Bound Procedures procedure, public :: is_allocated procedure, public :: string","tags":"","loc":"module/string_m.html"},{"title":"object_m – ","text":"Used by Descendants: object_s module~~object_m~~UsedByGraph module~object_m object_m module~sourcery_m sourcery_m module~sourcery_m->module~object_m module~oracle_m oracle_m module~sourcery_m->module~oracle_m module~oracle_m->module~object_m module~object_s object_s module~object_s->module~object_m module~oracle_s oracle_s module~oracle_s->module~oracle_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces mark_as_defined user_defined Abstract Interfaces write_interface Derived Types object_t Interfaces interface private pure module module subroutine mark_as_defined(self) Implementation → Mark the object as user-defined Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self interface private pure module module function user_defined(self) result(is_defined) Implementation → Return a boolean result indicating whether self object has been initialized since its declaration Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical Abstract Interfaces abstract interface private subroutine write_interface(self, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self integer, intent(in) :: unit character, intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character, intent(inout) :: iomsg Derived Types type, public, abstract :: object_t Abstract type to ensure all objects extending it implement the required methods Read more… Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Default initialization indicates not yet user-defined Type-Bound Procedures procedure, public :: mark_as_defined procedure, public :: user_defined generic, public :: write(formatted) => write_formatted procedure(write_interface), public :: write_formatted","tags":"","loc":"module/object_m.html"},{"title":"test_m – ","text":"Define an abstract test_t type with deferred bindings (\"subject\" and \"results\")\nused by a type-bound procedure (\"report\") for reporting test results.  The \"report\"\nprocedure thus represents an implementation of the Template Method pattern. Uses test_result_m module~~test_m~~UsesGraph module~test_m test_m module~test_result_m test_result_m module~test_m->module~test_result_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: test_s module~~test_m~~UsedByGraph module~test_m test_m module~sourcery_m sourcery_m module~sourcery_m->module~test_m module~test_s test_s module~test_s->module~test_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces report Abstract Interfaces results_interface subject_interface Derived Types test_t Interfaces interface private module module subroutine report(test, passes, tests) Implementation → Print the test results and increment the tallies of passing tests and total tests Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: test integer, intent(inout) :: passes integer, intent(inout) :: tests Abstract Interfaces abstract interface private function results_interface() result(test_results) The result is an array of test results for subsequent reporting in the \"report\" type-bound procedure Arguments None Return Value type( test_result_t ),allocatable, (:) abstract interface private pure function subject_interface() result(specimen) The result is the name of the test specimen (the subject of testing) Arguments None Return Value character(len=:),allocatable Derived Types type, public, abstract :: test_t Facilitate testing and test reporting Type-Bound Procedures procedure, public :: report procedure(results_interface), public, nopass :: results procedure(subject_interface), public, nopass :: subject","tags":"","loc":"module/test_m.html"},{"title":"user_defined_collectives_s – ","text":"Uses Ancestors: user_defined_collectives_m module~~user_defined_collectives_s~~UsesGraph module~user_defined_collectives_s user_defined_collectives_s module~user_defined_collectives_m user_defined_collectives_m module~user_defined_collectives_s->module~user_defined_collectives_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures co_all Module Procedures module procedure co_all module module subroutine co_all(boolean) Interface → Arguments Type Intent Optional Attributes Name logical, intent(inout) :: boolean","tags":"","loc":"module/user_defined_collectives_s.html"},{"title":"object_s – ","text":"Uses Ancestors: object_m module~~object_s~~UsesGraph module~object_s object_s module~object_m object_m module~object_s->module~object_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures mark_as_defined user_defined Module Procedures module procedure mark_as_defined pure module module subroutine mark_as_defined(self) Interface → Arguments Type Intent Optional Attributes Name class( object_t ), intent(inout) :: self module procedure user_defined pure module module function user_defined(self) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( object_t ), intent(in) :: self Return Value logical","tags":"","loc":"module/object_s.html"},{"title":"file_s – ","text":"Uses assert_m iso_fortran_env Ancestors: file_m module~~file_s~~UsesGraph module~file_s file_s assert_m assert_m module~file_s->assert_m iso_fortran_env iso_fortran_env module~file_s->iso_fortran_env module~file_m file_m module~file_s->module~file_m module~string_m string_m module~file_m->module~string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct lines read_lines write_lines Module Procedures module procedure construct module procedure construct() Arguments None module procedure lines pure module module function lines(self) result(my_lines) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self Return Value type( string_t ),allocatable, (:) module procedure read_lines module procedure read_lines() Arguments None module procedure write_lines impure elemental module module subroutine write_lines(self, file_name) Interface → Arguments Type Intent Optional Attributes Name class( file_t ), intent(in) :: self type( string_t ), intent(in), optional :: file_name","tags":"","loc":"module/file_s.html"},{"title":"units_s – ","text":"Uses assert_m Ancestors: units_m module~~units_s~~UsesGraph module~units_s units_s assert_m assert_m module~units_s->assert_m module~units_m units_m module~units_s->module~units_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures add assign_units divide get_system get_units has_density_units has_energy_units has_length_units has_mass_units has_power_units has_specific_energy_units has_stress_units has_temperature_units has_time_units has_velocity_units integer_power is_dimensionless multiply negate real_power set_units subtract Module Procedures module procedure add impure elemental module module function add(lhs, rhs) result(total) Interface → Require consistent operand units Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) module procedure assign_units pure module module subroutine assign_units(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: lhs class( units ), intent(in) :: rhs module procedure divide elemental module module function divide(numerator, denominator) result(ratio) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: numerator class( units ), intent(in) :: denominator Return Value type( units ) module procedure get_system impure elemental module module function get_system(this) result(system_of_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer module procedure get_units module module function get_units(this) result(exponents) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value integer(num_fundamental) module procedure has_density_units elemental module module function has_density_units(this) result(density_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_energy_units elemental module module function has_energy_units(this) result(energy_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_length_units elemental module module function has_length_units(this) result(length_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_mass_units elemental module module function has_mass_units(this) result(mass_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_power_units elemental module module function has_power_units(this) result(power_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_specific_energy_units elemental module module function has_specific_energy_units(this) result(specific_energy_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_stress_units elemental module module function has_stress_units(this) result(stress_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_temperature_units elemental module module function has_temperature_units(this) result(temperature_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_time_units elemental module module function has_time_units(this) result(time_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure has_velocity_units elemental module module function has_velocity_units(this) result(velocity_units) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure integer_power impure elemental module module function integer_power(this, exponent_) result(this_raised) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this integer, intent(in) :: exponent_ Return Value type( units ) module procedure is_dimensionless elemental module module function is_dimensionless(this) result(nondimensional) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value logical module procedure multiply elemental module module function multiply(lhs, rhs) result(product_) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units ) module procedure negate elemental module module function negate(this) result(negative_this) Interface → Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this Return Value type( units ) module procedure real_power impure elemental module module function real_power(this, exponent_) result(this_raised) Interface → Require dimensionless operand => result is default-initialized as dimensionless Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: this real, intent(in) :: exponent_ Return Value type( units ) module procedure set_units pure module module subroutine set_units(this, exponents, system) Interface → define units exponents Arguments Type Intent Optional Attributes Name class( units ), intent(inout) :: this integer, intent(in) :: exponents (num_fundamental) integer, intent(in) :: system module procedure subtract impure elemental module module function subtract(lhs, rhs) result(difference) Interface → Require consistent operand units Arguments Type Intent Optional Attributes Name class( units ), intent(in) :: lhs class( units ), intent(in) :: rhs Return Value type( units )","tags":"","loc":"module/units_s.html"},{"title":"array_functions_s – ","text":"Uses assert_m Ancestors: array_functions_m module~~array_functions_s~~UsesGraph module~array_functions_s array_functions_s assert_m assert_m module~array_functions_s->assert_m module~array_functions_m array_functions_m module~array_functions_s->module~array_functions_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures column_vectors concatenate_columns concatenate_rows Module Procedures module procedure column_vectors pure module module function column_vectors(vector_field) result(array_of_3D_column_vectors) Interface → Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:,:,:) :: vector_field Return Value real,dimension(:,:), allocatable module procedure concatenate_columns pure module module function concatenate_columns(a, b) result(concatenated) Interface → Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array\nelement references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler\nto order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape\nis likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance\nbottleneck, try replacing this implementation with element-by-element copying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:), allocatable module procedure concatenate_rows pure module module function concatenate_rows(a, b) result(concatenated) Interface → For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries.\nIf this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element\ncopying using do concurrent. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: a real, intent(in), dimension(:,:) :: b Return Value real,dimension(:,:), allocatable","tags":"","loc":"module/array_functions_s.html"},{"title":"data_partition_s – ","text":"Uses assert_m Ancestors: data_partition_m module~~data_partition_s~~UsesGraph module~data_partition_s data_partition_s assert_m assert_m module~data_partition_s->assert_m module~data_partition_m data_partition_m module~data_partition_s->module~data_partition_m iso_fortran_env iso_fortran_env module~data_partition_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables verbose Module Procedures define_partitions first gather_real32_1D_array gather_real32_2D_array gather_real64_1D_array gather_real64_2D_array last Variables Type Visibility Attributes Name Initial logical, private, parameter :: verbose = .false. Module Procedures module procedure define_partitions module module subroutine define_partitions(cardinality) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: cardinality module procedure first pure module module function first(image_number) result(first_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer module procedure gather_real32_1D_array module module subroutine gather_real32_1D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure gather_real32_2D_array module module subroutine gather_real32_2D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure gather_real64_1D_array module module subroutine gather_real64_1D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure gather_real64_2D_array module module subroutine gather_real64_2D_array(a, result_image, dim) Interface → Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: a (:,:) integer, intent(in), optional :: result_image integer, intent(in), optional :: dim module procedure last pure module module function last(image_number) result(last_index) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: image_number Return Value integer","tags":"","loc":"module/data_partition_s.html"},{"title":"formats_s – ","text":"Construct separated-value formats Uses Ancestors: formats_m module~~formats_s~~UsesGraph module~formats_s formats_s module~formats_m formats_m module~formats_s->module~formats_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures separated_values Module Procedures module procedure separated_values pure module module function separated_values(separator, mold) result(format_string) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: separator class(*), intent(in) :: mold (..) Return Value character(len=:),allocatable","tags":"","loc":"module/formats_s.html"},{"title":"string_functions_s – ","text":"Uses Ancestors: string_functions_m module~~string_functions_s~~UsesGraph module~string_functions_s string_functions_s module~string_functions_m string_functions_m module~string_functions_s->module~string_functions_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures base_name file_extension integer_to_string Module Procedures module procedure base_name pure module module function base_name(file_name) result(base) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable module procedure file_extension pure module module function file_extension(file_name) result(extension) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Return Value character(len=:),allocatable module procedure integer_to_string pure module module function integer_to_string(integer_value) result(characters) Interface → Arguments Type Intent Optional Attributes Name integer, intent(in) :: integer_value Return Value character(len=:),allocatable","tags":"","loc":"module/string_functions_s.html"},{"title":"string_s – ","text":"Uses Ancestors: string_m module~~string_s~~UsesGraph module~string_s string_s module~string_m string_m module~string_s->module~string_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures array_of_strings construct is_allocated string Module Procedures module procedure array_of_strings pure module module function array_of_strings(delimited_strings, delimiter) result(strings_array) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: delimited_strings character(len=*), intent(in) :: delimiter Return Value type( string_t ),allocatable, (:) module procedure construct module procedure construct() Arguments None module procedure is_allocated elemental module module function is_allocated(self) result(string_allocated) Interface → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value logical module procedure string pure module module function string(self) result(raw_string) Interface → Arguments Type Intent Optional Attributes Name class( string_t ), intent(in) :: self Return Value character(len=:),allocatable","tags":"","loc":"module/string_s.html"},{"title":"test_s – ","text":"Uses Ancestors: test_m module~~test_s~~UsesGraph module~test_s test_s module~test_m test_m module~test_s->module~test_m module~test_result_m test_result_m module~test_m->module~test_result_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures report Module Procedures module procedure report module module subroutine report(test, passes, tests) Interface → Arguments Type Intent Optional Attributes Name class( test_t ), intent(in) :: test integer, intent(inout) :: passes integer, intent(inout) :: tests","tags":"","loc":"module/test_s.html"},{"title":"command_line_s – ","text":"Uses Ancestors: command_line_m module~~command_line_s~~UsesGraph module~command_line_s command_line_s module~command_line_m command_line_m module~command_line_s->module~command_line_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures argument_present flag_value Module Procedures module procedure argument_present module module function argument_present(acceptable_argument) result(found) Interface → list of acceptable arguments\nsample list: [character(len=len(longest_argument)):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS and slashes support Windows Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: acceptable_argument (:) sample list: [character(len=len( )):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"]\nwhere dashes support Linux/macOS, slashes support Windows, and must be replaced\nby the longest list element (\"--benchmark\" above) Return Value logical module procedure flag_value module module function flag_value(flag) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: flag Return Value character(len=:),allocatable","tags":"","loc":"module/command_line_s.html"},{"title":"co_object_s – ","text":"Uses Ancestors: co_object_m module~~co_object_s~~UsesGraph module~co_object_s co_object_s module~co_object_m co_object_m module~co_object_s->module~co_object_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures mark_as_defined user_defined Module Procedures module procedure mark_as_defined pure module module subroutine mark_as_defined(self) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: self module procedure user_defined pure module module function user_defined(self) result(is_defined) Interface → Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: self Return Value logical","tags":"","loc":"module/co_object_s.html"},{"title":"test_result_s – ","text":"Uses Ancestors: test_result_m module~~test_result_s~~UsesGraph module~test_result_s test_result_s module~test_result_m test_result_m module~test_result_s->module~test_result_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures characterize construct passed Module Procedures module procedure characterize pure module module function characterize(self) result(characterization) Interface → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value character(len=:),allocatable module procedure construct module procedure construct() Arguments None module procedure passed elemental module module function passed(self) result(test_passed) Interface → Arguments Type Intent Optional Attributes Name class( test_result_t ), intent(in) :: self Return Value logical","tags":"","loc":"module/test_result_s.html"},{"title":"oracle_s – ","text":"define procedures corresponding to the interface bodies in oracle_m Uses Ancestors: oracle_m module~~oracle_s~~UsesGraph module~oracle_s oracle_s module~oracle_m oracle_m module~oracle_s->module~oracle_m module~object_m object_m module~oracle_m->module~object_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures within_tolerance Module Procedures module procedure within_tolerance module module function within_tolerance(self, reference, tolerance) result(in_tolerance) Interface → Arguments Type Intent Optional Attributes Name class( oracle_t ), intent(in) :: self class( oracle_t ), intent(in) :: reference real, intent(in) :: tolerance Return Value logical","tags":"","loc":"module/oracle_s.html"},{"title":"sourcery_m.f90 – ","text":"This file depends on sourcefile~~sourcery_m.f90~~EfferentGraph sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~formats_m.f90 formats_m.F90 sourcefile~sourcery_m.f90->sourcefile~formats_m.f90 sourcefile~co_object_m.f90 co_object_m.f90 sourcefile~sourcery_m.f90->sourcefile~co_object_m.f90 sourcefile~test_m.f90 test_m.f90 sourcefile~sourcery_m.f90->sourcefile~test_m.f90 sourcefile~user_defined_collectives_m.f90 user_defined_collectives_m.f90 sourcefile~sourcery_m.f90->sourcefile~user_defined_collectives_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~sourcery_m.f90->sourcefile~file_m.f90 sourcefile~command_line_m.f90 command_line_m.f90 sourcefile~sourcery_m.f90->sourcefile~command_line_m.f90 sourcefile~test_result_m.f90 test_result_m.f90 sourcefile~sourcery_m.f90->sourcefile~test_result_m.f90 sourcefile~string_m.f90 string_m.f90 sourcefile~sourcery_m.f90->sourcefile~string_m.f90 sourcefile~oracle_m.f90 oracle_m.f90 sourcefile~sourcery_m.f90->sourcefile~oracle_m.f90 sourcefile~object_m.f90 object_m.f90 sourcefile~sourcery_m.f90->sourcefile~object_m.f90 sourcefile~data_partition_m.f90 data_partition_m.f90 sourcefile~sourcery_m.f90->sourcefile~data_partition_m.f90 sourcefile~units_m.f90 units_m.f90 sourcefile~sourcery_m.f90->sourcefile~units_m.f90 sourcefile~test_m.f90->sourcefile~test_result_m.f90 sourcefile~file_m.f90->sourcefile~string_m.f90 sourcefile~oracle_m.f90->sourcefile~object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sourcery_m Source Code sourcery_m.f90 Source Code module sourcery_m !! export all public entities from every other sourcery module implicit none use command_line_m use string_m use file_m use test_result_m use formats_m use oracle_m use object_m use user_defined_collectives_m use data_partition_m use test_m use units_m use co_object_m end module sourcery_m","tags":"","loc":"sourcefile/sourcery_m.f90.html"},{"title":"command_line_m.f90 – ","text":"Files dependent on this one sourcefile~~command_line_m.f90~~AfferentGraph sourcefile~command_line_m.f90 command_line_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~command_line_m.f90 sourcefile~command_line_s.f90 command_line_s.f90 sourcefile~command_line_s.f90->sourcefile~command_line_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules command_line_m Source Code command_line_m.f90 Source Code module command_line_m !! return command line argument information implicit none private public :: command_line_t type command_line_t contains procedure , nopass :: argument_present procedure , nopass :: flag_value end type interface module function argument_present ( acceptable_argument ) result ( found ) implicit none !! result is .true. only if a command-line argument matches an element of this function's argument character ( len =* ), intent ( in ) :: acceptable_argument (:) !! sample list: [character(len=len(<longest_argument>)):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"] !! where dashes support Linux/macOS, slashes support Windows, and <longest_argument> must be replaced !! by the longest list element (\"--benchmark\" above) logical found end function module function flag_value ( flag ) !! result is the value passed adjacent to a command-line flag implicit none character ( len =* ), intent ( in ) :: flag character ( len = :), allocatable :: flag_value end function end interface end module","tags":"","loc":"sourcefile/command_line_m.f90.html"},{"title":"formats_m.F90 – ","text":"Files dependent on this one sourcefile~~formats_m.f90~~AfferentGraph sourcefile~formats_m.f90 formats_m.F90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~formats_m.f90 sourcefile~formats_s.f90 formats_s.F90 sourcefile~formats_s.f90->sourcefile~formats_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules formats_m Source Code formats_m.F90 Source Code module formats_m !! Useful strings for formatting `print` and `write` statements implicit none character ( len =* ), parameter :: csv = \"(*(G0,:,','))\" !! comma-separated values character ( len =* ), parameter :: cscv = \"(*('(',G0,',',G0,')',:,',')))\" !! comma-separated complex values interface pure module function separated_values ( separator , mold ) result ( format_string ) character ( len =* ), intent ( in ) :: separator #ifndef NAGFOR class ( * ), intent ( in ) :: mold (..) #else class ( * ), intent ( in ) :: mold (:) #endif character ( len = :), allocatable :: format_string end function end interface end module","tags":"","loc":"sourcefile/formats_m.f90.html"},{"title":"test_result_m.f90 – ","text":"Files dependent on this one sourcefile~~test_result_m.f90~~AfferentGraph sourcefile~test_result_m.f90 test_result_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~test_result_m.f90 sourcefile~test_m.f90 test_m.f90 sourcefile~sourcery_m.f90->sourcefile~test_m.f90 sourcefile~test_m.f90->sourcefile~test_result_m.f90 sourcefile~test_result_s.f90 test_result_s.f90 sourcefile~test_result_s.f90->sourcefile~test_result_m.f90 sourcefile~test_s.f90 test_s.f90 sourcefile~test_s.f90->sourcefile~test_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules test_result_m Source Code test_result_m.f90 Source Code module test_result_m !! Define an abstraction for describing test intentions and results implicit none private public :: test_result_t type test_result_t !! Encapsulate test descriptions and outcomes and reporting private character ( len = :), allocatable :: description_ logical passed_ contains procedure :: characterize procedure :: passed end type interface test_result_t elemental module function construct ( description , passed ) result ( test_result ) !! The result is a test_result_t object with the components defined by the dummy arguments implicit none character ( len =* ), intent ( in ) :: description logical , intent ( in ) :: passed type ( test_result_t ) test_result end function end interface interface pure module function characterize ( self ) result ( characterization ) !! The result is a character description of the test and its outcome implicit none class ( test_result_t ), intent ( in ) :: self character ( len = :), allocatable :: characterization end function elemental module function passed ( self ) result ( test_passed ) !! The result is a character description of the test and its outcome implicit none class ( test_result_t ), intent ( in ) :: self logical test_passed end function end interface end module test_result_m","tags":"","loc":"sourcefile/test_result_m.f90.html"},{"title":"file_m.f90 – ","text":"This file depends on sourcefile~~file_m.f90~~EfferentGraph sourcefile~file_m.f90 file_m.f90 sourcefile~string_m.f90 string_m.f90 sourcefile~file_m.f90->sourcefile~string_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~file_m.f90~~AfferentGraph sourcefile~file_m.f90 file_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~file_m.f90 sourcefile~file_s.f90 file_s.f90 sourcefile~file_s.f90->sourcefile~file_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules file_m Source Code file_m.f90 Source Code module file_m !! A representation of a file as an object use string_m , only : string_t private public :: file_t type file_t private type ( string_t ), allocatable :: lines_ (:) contains procedure :: lines procedure :: write_lines end type interface file_t impure elemental module function read_lines ( file_name ) result ( file_object ) implicit none type ( string_t ), intent ( in ) :: file_name type ( file_t ) file_object end function pure module function construct ( lines ) result ( file_object ) implicit none type ( string_t ), intent ( in ), allocatable :: lines (:) type ( file_t ) file_object end function end interface interface pure module function lines ( self ) result ( my_lines ) implicit none class ( file_t ), intent ( in ) :: self type ( string_t ), allocatable :: my_lines (:) end function impure elemental module subroutine write_lines ( self , file_name ) implicit none class ( file_t ), intent ( in ) :: self type ( string_t ), intent ( in ), optional :: file_name end subroutine end interface end module file_m","tags":"","loc":"sourcefile/file_m.f90.html"},{"title":"user_defined_collectives_s.f90 – ","text":"This file depends on sourcefile~~user_defined_collectives_s.f90~~EfferentGraph sourcefile~user_defined_collectives_s.f90 user_defined_collectives_s.f90 sourcefile~user_defined_collectives_m.f90 user_defined_collectives_m.f90 sourcefile~user_defined_collectives_s.f90->sourcefile~user_defined_collectives_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules user_defined_collectives_s Source Code user_defined_collectives_s.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( user_defined_collectives_m ) user_defined_collectives_s implicit none contains module procedure co_all call co_reduce ( boolean , both ) contains pure function both ( lhs , rhs ) result ( lhs_and_rhs ) logical , intent ( in ) :: lhs , rhs logical lhs_and_rhs lhs_and_rhs = lhs . and . rhs end function end procedure end submodule user_defined_collectives_s","tags":"","loc":"sourcefile/user_defined_collectives_s.f90.html"},{"title":"object_s.f90 – ","text":"This file depends on sourcefile~~object_s.f90~~EfferentGraph sourcefile~object_s.f90 object_s.f90 sourcefile~object_m.f90 object_m.f90 sourcefile~object_s.f90->sourcefile~object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules object_s Source Code object_s.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( object_m ) object_s implicit none contains module procedure mark_as_defined self % defined = . true . end procedure module procedure user_defined is_defined = self % defined end procedure end submodule","tags":"","loc":"sourcefile/object_s.f90.html"},{"title":"file_s.f90 – ","text":"This file depends on sourcefile~~file_s.f90~~EfferentGraph sourcefile~file_s.f90 file_s.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~file_s.f90->sourcefile~file_m.f90 sourcefile~string_m.f90 string_m.f90 sourcefile~file_m.f90->sourcefile~string_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules file_s Source Code file_s.f90 Source Code submodule ( file_m ) file_s use iso_fortran_env , only : iostat_end , iostat_eor , output_unit use assert_m , only : assert implicit none contains module procedure construct file_object % lines_ = lines end procedure module procedure write_lines integer file_unit , io_status , l call assert ( allocated ( self % lines_ ), \"file_t%write_lines: allocated(self%lines_)\" ) if ( present ( file_name )) then open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'unknown' , iostat = io_status , action = 'write' ) call assert ( io_status == 0 , \"write_lines: io_status==0 after 'open' statement\" , file_name % string ()) else file_unit = output_unit end if do l = 1 , size ( self % lines_ ) write ( file_unit , * ) self % lines_ ( l )% string () end do if ( present ( file_name )) close ( file_unit ) end procedure module procedure read_lines integer io_status , file_unit , line_num character ( len = :), allocatable :: line integer , parameter :: max_message_length = 128 character ( len = max_message_length ) error_message integer , allocatable :: lengths (:) open ( newunit = file_unit , file = file_name % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) call assert ( io_status == 0 , \"read_lines: io_status==0 after 'open' statement\" , file_name % string ()) lengths = line_lengths ( file_unit ) associate ( num_lines => size ( lengths )) allocate ( file_object % lines_ ( num_lines )) do line_num = 1 , num_lines allocate ( character ( len = lengths ( line_num )) :: line ) read ( file_unit , '(a)' , iostat = io_status , iomsg = error_message ) line call assert ( io_status == 0 , \"read_lines: io_status==0 after line read\" , error_message ) file_object % lines_ ( line_num ) = string_t ( line ) deallocate ( line ) end do end associate close ( file_unit ) contains function line_count ( file_unit ) result ( num_lines ) integer , intent ( in ) :: file_unit integer num_lines rewind ( file_unit ) num_lines = 0 do read ( file_unit , * , iostat = io_status ) if ( io_status == iostat_end ) exit num_lines = num_lines + 1 end do rewind ( file_unit ) end function function line_lengths ( file_unit ) result ( lengths ) integer , intent ( in ) :: file_unit integer , allocatable :: lengths (:) integer io_status character ( len = 1 ) c associate ( num_lines => line_count ( file_unit )) allocate ( lengths ( num_lines ), source = 0 ) rewind ( file_unit ) do line_num = 1 , num_lines do read ( file_unit , '(a)' , advance = 'no' , iostat = io_status , iomsg = error_message ) c if ( io_status == iostat_eor . or . io_status == iostat_end ) exit lengths ( line_num ) = lengths ( line_num ) + 1 end do end do rewind ( file_unit ) end associate end function end procedure module procedure lines my_lines = self % lines_ end procedure end submodule file_s","tags":"","loc":"sourcefile/file_s.f90.html"},{"title":"units_s.f90 – ","text":"This file depends on sourcefile~~units_s.f90~~EfferentGraph sourcefile~units_s.f90 units_s.f90 sourcefile~units_m.f90 units_m.f90 sourcefile~units_s.f90->sourcefile~units_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules units_s Source Code units_s.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( units_m ) units_s use assert_m , only : assert implicit none contains module procedure set_units !! define units exponents this % exponents_ = exponents this % system = system end procedure module procedure get_system system_of_units = this % system end procedure module procedure get_units exponents = this % exponents_ end procedure module procedure assign_units lhs % exponents_ = rhs % exponents_ lhs % system = rhs % system end procedure module procedure is_dimensionless nondimensional = all ([ this % exponents_ == 0 ]) . and . this % system == dimensionless end procedure module procedure has_length_units length_units = this % exponents_ ( m ) == 1 . and . all ( this % exponents_ ([ kg , sec , K ]) == 0 ) end procedure module procedure has_mass_units mass_units = this % exponents_ ( kg ) == 1 . and . all ( this % exponents_ ([ m , sec , K ]) == 0 ) end procedure module procedure has_time_units time_units = this % exponents_ ( sec ) == 1 . and . all ( this % exponents_ ([ m , kg , K ]) == 0 ) end procedure module procedure has_temperature_units temperature_units = this % exponents_ ( K ) == 1 . and . all ( this % exponents_ ([ m , kg , sec ]) == 0 ) end procedure module procedure has_velocity_units velocity_units = all ( this % exponents_ ([ m , sec ]) == [ 1 , - 1 ]) . and . all ( this % exponents_ ([ kg , K ]) == 0 ) end procedure module procedure has_energy_units energy_units = all ( this % exponents_ ([ kg , m , sec ]) == [ 1 , 2 , - 2 ]) . and . this % exponents_ ( K ) == 0 end procedure module procedure has_density_units density_units = all ( this % exponents_ ([ kg , m ]) == [ 1 , - 3 ]) . and . all ( this % exponents_ ([ sec , K ]) == 0 ) end procedure module procedure has_specific_energy_units specific_energy_units = all ( this % exponents_ ([ m , sec ]) == [ 2 , - 2 ]) . and . all ( this % exponents_ ([ kg , K ]) == 0 ) end procedure module procedure has_stress_units stress_units = all ( this % exponents_ ([ kg , m , sec ]) == [ 1 , - 1 , - 2 ]) . and . this % exponents_ ( K ) == 0 end procedure module procedure has_power_units power_units = all ( this % exponents_ ([ kg , m , sec ]) == [ 1 , 2 , - 3 ]) . and . this % exponents_ ( K ) == 0 end procedure module procedure integer_power this_raised % system = this % system this_raised % exponents_ = exponent_ * this % exponents_ end procedure module procedure real_power call assert ( this % is_dimensionless (), & & \"units%real_power: an entity raised to a real power must be dimensionless\" ) !! Require dimensionless operand => result is default-initialized as dimensionless end procedure module procedure negate negative_this % exponents_ = this % exponents_ negative_this % system = this % system end procedure module procedure add !! Require consistent operand units associate ( preconditions => [ lhs % system == rhs % system , lhs % exponents_ == rhs % exponents_ ] ) call assert ( all ( preconditions ), \"units%add: consistent operands units\" ) end associate total % exponents_ = lhs % exponents_ total % system = lhs % system end procedure module procedure subtract !! Require consistent operand units associate ( preconditions => [ lhs % system == rhs % system , lhs % exponents_ == rhs % exponents_ ] ) call assert ( all ( preconditions ), \"units%subtract: consistent operand units\" ) end associate difference % exponents_ = lhs % exponents_ difference % system = lhs % system end procedure module procedure multiply call assert ( lhs % system == rhs % system , \"units%multiply: consistent operand units\" ) product_ % exponents_ = lhs % exponents_ + rhs % exponents_ product_ % system = lhs % system end procedure module procedure divide call assert ( numerator % system == denominator % system , \"units%divide: consistent operand units\" ) ratio % exponents_ = numerator % exponents_ - denominator % exponents_ ratio % system = merge ( numerator % system , dimensionless , any ( ratio % exponents_ /= 0 )) end procedure end submodule units_s","tags":"","loc":"sourcefile/units_s.f90.html"},{"title":"oracle_m.f90 – ","text":"This file depends on sourcefile~~oracle_m.f90~~EfferentGraph sourcefile~oracle_m.f90 oracle_m.f90 sourcefile~object_m.f90 object_m.f90 sourcefile~oracle_m.f90->sourcefile~object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~oracle_m.f90~~AfferentGraph sourcefile~oracle_m.f90 oracle_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~oracle_m.f90 sourcefile~oracle_s.f90 oracle_s.f90 sourcefile~oracle_s.f90->sourcefile~oracle_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules oracle_m Source Code oracle_m.f90 Source Code module oracle_m !! verify actual output against expected use object_m , only : object_t implicit none private public :: oracle_t type , abstract , extends ( object_t ) :: oracle_t !! define procedures for testing output values against expected values contains procedure ( subtract_interface ), deferred :: subtract procedure ( norm_interface ), deferred :: norm generic :: operator ( - ) => subtract procedure :: within_tolerance end type abstract interface function subtract_interface ( self , rhs ) result ( difference ) !! result has components corresponding to subtracting rhs's components fron self object's components import oracle_t implicit none class ( oracle_t ), intent ( in ) :: self , rhs class ( oracle_t ), allocatable :: difference end function pure function norm_interface ( self ) result ( norm_of_self ) !! result is a norm of the array formed by concatenating the real components of self object import oracle_t implicit none class ( oracle_t ), intent ( in ) :: self real norm_of_self end function end interface interface module function within_tolerance ( self , reference , tolerance ) result ( in_tolerance ) !! template method with true result iff the difference in state vectors (self - reference) has a norm within tolerance !! (impure because of internal call to 'subtract' binding) !! The existence of self procedure eliminates the need to rewrite similar code for every oracle child type. implicit none class ( oracle_t ), intent ( in ) :: self , reference real , intent ( in ) :: tolerance logical in_tolerance end function end interface end module","tags":"","loc":"sourcefile/oracle_m.f90.html"},{"title":"array_functions_m.f90 – ","text":"Files dependent on this one sourcefile~~array_functions_m.f90~~AfferentGraph sourcefile~array_functions_m.f90 array_functions_m.f90 sourcefile~array_functions_s.f90 array_functions_s.f90 sourcefile~array_functions_s.f90->sourcefile~array_functions_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules array_functions_m Source Code array_functions_m.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module array_functions_m !! author: Damian Rouson !! date: 04/25/2019 !! !! Functionally pure array utilities implicit none private public :: operator (. catColumns .) public :: operator (. catRows .) public :: operator (. columnVectors .) !! Because the Fortran standard requires that operator dummy arguments have the intent(in) attribute !! exposing only the operator and not the function names communicates more information in the !! public interface and in code using this interface. interface operator (. columnVectors .) module procedure column_vectors end interface interface operator (. catColumns .) module procedure concatenate_columns end interface interface operator (. catRows .) module procedure concatenate_rows end interface interface pure module function column_vectors ( vector_field ) result ( array_of_3D_column_vectors ) !! Result is array of 3D column vectors of dimension (space_dim,nx*ny*nz) reshaped from vector-field argument !! of dimension (nx,ny,nz,space_dim) implicit none real , dimension (:,:,:,:), intent ( in ) :: vector_field real , dimension (:,:), allocatable :: array_of_3D_column_vectors end function pure module function concatenate_columns ( a , b ) result ( concatenated ) !! Result contains the concatenation of the columns of argument a with the columns of argument b implicit none real , dimension (:,:), intent ( in ) :: a , b real , dimension (:,:), allocatable :: concatenated end function pure module function concatenate_rows ( a , b ) result ( concatenated ) !! Result contains the concatenation of the rows of argument a with the rows of argument b implicit none real , dimension (:,:), intent ( in ) :: a , b real , dimension (:,:), allocatable :: concatenated end function end interface end module","tags":"","loc":"sourcefile/array_functions_m.f90.html"},{"title":"data_partition_m.f90 – ","text":"Files dependent on this one sourcefile~~data_partition_m.f90~~AfferentGraph sourcefile~data_partition_m.f90 data_partition_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~data_partition_m.f90 sourcefile~data_partition_s.f90 data_partition_s.f90 sourcefile~data_partition_s.f90->sourcefile~data_partition_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules data_partition_m Source Code data_partition_m.f90 Source Code module data_partition_m !! distribute data identification numbers across images such that the number of !! items differs by at most 1 between any two images. use iso_fortran_env , only : real32 , real64 implicit none private public :: data_partition_t type data_partition_t !! encapsulate a description of the data subset the executing image owns private contains procedure , nopass :: define_partitions procedure , nopass :: first procedure , nopass :: last procedure , nopass , private :: gather_real32_2D_array , gather_real64_2D_array , gather_real32_1D_array , gather_real64_1D_array generic :: gather => gather_real32_2D_array , gather_real64_2D_array , gather_real32_1D_array , gather_real64_1D_array end type integer , allocatable :: first_datum (:), last_datum (:) interface module subroutine define_partitions ( cardinality ) !! define the range of data identification numbers owned by the executing image integer , intent ( in ) :: cardinality end subroutine pure module function first ( image_number ) result ( first_index ) !! the result is the first identification number owned by the executing image implicit none integer , intent ( in ) :: image_number integer first_index end function pure module function last ( image_number ) result ( last_index ) !! the result is the last identification number owned by the executing image implicit none integer , intent ( in ) :: image_number integer last_index end function !! Gathers are inherently expensive and are best used either !! 1. Near the beginning/end of execution to amortize costs across an entire run or !! 2. Temporarily while developing/debugging code. module subroutine gather_real32_1D_array ( a , result_image , dim ) !! Gather the elements of an 1D array distributed along dimension dim onto result_image real ( real32 ), intent ( inout ) :: a (:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine module subroutine gather_real64_1D_array ( a , result_image , dim ) !! Gather the elements of an 1D array distributed along dimension dim onto result_image real ( real64 ), intent ( inout ) :: a (:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine module subroutine gather_real32_2D_array ( a , result_image , dim ) !! Gather the elements of an 2D array distributed along dimension dim onto result_image real ( real32 ), intent ( inout ) :: a (:,:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine module subroutine gather_real64_2D_array ( a , result_image , dim ) !! Gather the elements of an 2D array distributed along dimension dim onto result_image real ( real64 ), intent ( inout ) :: a (:,:) integer , intent ( in ), optional :: result_image integer , intent ( in ), optional :: dim end subroutine end interface end module data_partition_m","tags":"","loc":"sourcefile/data_partition_m.f90.html"},{"title":"array_functions_s.f90 – ","text":"This file depends on sourcefile~~array_functions_s.f90~~EfferentGraph sourcefile~array_functions_s.f90 array_functions_s.f90 sourcefile~array_functions_m.f90 array_functions_m.f90 sourcefile~array_functions_s.f90->sourcefile~array_functions_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules array_functions_s Source Code array_functions_s.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( array_functions_m ) array_functions_s use assert_m , only : assert implicit none contains module procedure column_vectors integer i , j , k associate ( n => shape ( vector_field ) ) call assert ( size ( n ) == 4 , \"3D vector field input\" ) allocate ( array_of_3D_column_vectors ( n ( 4 ), product ( n ( 1 : 3 )) ) ) do concurrent ( i = 1 : n ( 1 ), j = 1 : n ( 2 ), k = 1 : n ( 3 ) ) associate ( id => ( k - 1 ) * PRODUCT ( n ( 1 : 2 )) + ( j - 1 ) * n ( 1 ) + i ) array_of_3D_column_vectors (:, id ) = vector_field ( i , j , k ,:) end associate end do end associate end procedure module procedure concatenate_columns !! Using reshape rather than manipulating array elements directly frees the compiler to decide the particular order of array !! element references that best exploits the given platform.  Alternatively, do concurrent could instead free the compiler !! to order element accesses however is best. Trade-off: reshape requires the creation of temporary array results but reshape !! is likely to have more mature compiler support than do concurrent.  If this code turns out to be a critical performance !! bottleneck, try replacing this implementation with element-by-element copying using do concurrent. associate ( rows => size ( a , 1 )) associate ( cols => size ( a , 2 ) + size ( b , 2 )) associate ( a_unrolled => reshape ( a ,[ size ( a )])) associate ( b_unrolled => reshape ( b ,[ size ( b )])) call assert ( rows == size ( b , 1 ), \"array_functions: compatible shapes\" ) concatenated = reshape ( [ a_unrolled , b_unrolled ],[ rows , cols ] ) end associate ; end associate ; end associate ; end associate end procedure module procedure concatenate_rows !! For simplicity, this implementation invokes concatenate_columns at the cost of transpose creating additional temporaries. !! If this code turns out to be a critical performance bottleneck, try replacing this implementation with element-by-element !! copying using do concurrent. concatenated = transpose ( concatenate_columns ( transpose ( a ), transpose ( b )) ) end procedure end submodule","tags":"","loc":"sourcefile/array_functions_s.f90.html"},{"title":"data_partition_s.f90 – ","text":"This file depends on sourcefile~~data_partition_s.f90~~EfferentGraph sourcefile~data_partition_s.f90 data_partition_s.f90 sourcefile~data_partition_m.f90 data_partition_m.f90 sourcefile~data_partition_s.f90->sourcefile~data_partition_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules data_partition_s Source Code data_partition_s.f90 Source Code submodule ( data_partition_m ) data_partition_s use assert_m , only : assert implicit none logical , parameter :: verbose = . false . contains module procedure define_partitions if ( allocated ( first_datum )) deallocate ( first_datum ) if ( allocated ( last_datum )) deallocate ( last_datum ) associate ( ni => num_images () ) call assert ( ni <= cardinality , \"sufficient data for distribution across images\" , cardinality ) allocate ( first_datum ( ni ), last_datum ( ni )) block integer i , image do image = 1 , ni associate ( remainder => mod ( cardinality , ni ), quotient => cardinality / ni ) first_datum ( image ) = sum ([( quotient + overflow ( i , remainder ), i = 1 , image - 1 )]) + 1 last_datum ( image ) = first_datum ( image ) + quotient + overflow ( image , remainder ) - 1 end associate end do end block end associate contains pure function overflow ( im , excess ) result ( extra_datum ) integer , intent ( in ) :: im , excess integer extra_datum extra_datum = merge ( 1 , 0 , im <= excess ) end function end procedure module procedure first call assert ( allocated ( first_datum ), \"allocated(first_datum)\" ) first_index = first_datum ( image_number ) end procedure module procedure last call assert ( allocated ( last_datum ), \"allocated(last_datum)\" ) last_index = last_datum ( image_number ) end procedure module procedure gather_real32_1D_array if ( present ( dim )) call assert ( dim == 1 , \"dimensioned partitioned == 1\" ) associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real_1D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a ) else block real ( real32 ), allocatable , dimension (:) :: a_lower , a_upper a_lower = a ( 1 : first - 1 ) a_upper = a ( last + 1 :) a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then a ( 1 : first - 1 ) = a_lower a ( last + 1 :) = a_upper end if end block end if end associate end associate end procedure module procedure gather_real64_1D_array if ( present ( dim )) call assert ( dim == 1 , \"dimensioned partitioned == 1\" ) associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real_1D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a ) else block real ( real64 ), allocatable , dimension (:) :: a_lower , a_upper a_lower = a ( 1 : first - 1 ) a_upper = a ( last + 1 :) a ( 1 : first - 1 ) = 0. a ( last + 1 :) = 0. call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then a ( 1 : first - 1 ) = a_lower a ( last + 1 :) = a_upper end if end block end if end associate end associate end procedure module procedure gather_real32_2D_array integer dim_ if ( present ( dim )) then dim_ = dim else dim_ = 2 end if associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real32_2D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real32_2D_array: invalid dim argument\" end select call co_sum ( a ) else block real ( real32 ), allocatable , dimension (:,:) :: a_lower , a_upper select case ( dim_ ) case ( 1 ) a_lower = a ( 1 : first - 1 , :) a_upper = a ( last + 1 :, :) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a_lower = a (:, 1 : first - 1 ) a_upper = a (:, last + 1 :) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real32_2D_array: invalid dim argument\" end select call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = a_lower a ( last + 1 :, :) = a_upper case ( 2 ) a (:, 1 : first - 1 ) = a_lower a (:, last + 1 :) = a_upper case default error stop \"gather_real32_2D_array: invalid dim argument\" end select end if end block end if end associate end associate end procedure module procedure gather_real64_2D_array integer dim_ if ( present ( dim )) then dim_ = dim else dim_ = 2 end if associate ( me => this_image () ) if ( verbose ) then write ( 6 , * ) 'gather_real64_2D_array(): executing on image' , me flush ( 6 ) end if associate ( first => first ( me ), last => last ( me ) ) if (. not . present ( result_image )) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real64_2D_array: invalid dim argument\" end select call co_sum ( a ) else block real ( real64 ), allocatable , dimension (:,:) :: a_lower , a_upper select case ( dim_ ) case ( 1 ) a_lower = a ( 1 : first - 1 , :) a_upper = a ( last + 1 :, :) a ( 1 : first - 1 , :) = 0. a ( last + 1 :, :) = 0. case ( 2 ) a_lower = a (:, 1 : first - 1 ) a_upper = a (:, last + 1 :) a (:, 1 : first - 1 ) = 0. a (:, last + 1 :) = 0. case default error stop \"gather_real64_2D_array: invalid dim argument\" end select call co_sum ( a , result_image = result_image ) if ( result_image /= me ) then select case ( dim_ ) case ( 1 ) a ( 1 : first - 1 , :) = a_lower a ( last + 1 :, :) = a_upper case ( 2 ) a (:, 1 : first - 1 ) = a_lower a (:, last + 1 :) = a_upper case default error stop \"gather_real64_2D_array: invalid dim argument\" end select end if end block end if end associate end associate end procedure end submodule data_partition_s","tags":"","loc":"sourcefile/data_partition_s.f90.html"},{"title":"formats_s.F90 – ","text":"This file depends on sourcefile~~formats_s.f90~~EfferentGraph sourcefile~formats_s.f90 formats_s.F90 sourcefile~formats_m.f90 formats_m.F90 sourcefile~formats_s.f90->sourcefile~formats_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules formats_s Source Code formats_s.F90 Source Code submodule ( formats_m ) formats_s !! Construct separated-value formats implicit none contains module procedure separated_values character ( len =* ), parameter :: prefix = \"(*(G0,:,'\" character ( len =* ), parameter :: suffix = \"'))\" character ( len =* ), parameter :: complex_prefix = \"(*('(',G0,',',G0,')',:,'\" #ifndef NAGFOR select rank ( mold ) rank ( 1 ) #endif select type ( mold ) type is ( complex ) format_string = complex_prefix // separator // suffix type is ( real ) format_string = prefix // separator // suffix type is ( integer ) format_string = prefix // separator // suffix type is ( character ( len =* )) format_string = prefix // separator // suffix class default error stop \"format_s separated_values: unsupported type\" end select #ifndef NAGFOR rank default error stop \"formats_s separated_values: unsupported rank\" end select #endif end procedure end submodule formats_s","tags":"","loc":"sourcefile/formats_s.f90.html"},{"title":"string_functions_s.f90 – ","text":"This file depends on sourcefile~~string_functions_s.f90~~EfferentGraph sourcefile~string_functions_s.f90 string_functions_s.f90 sourcefile~string_functions_m.f90 string_functions_m.f90 sourcefile~string_functions_s.f90->sourcefile~string_functions_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules string_functions_s Source Code string_functions_s.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( string_functions_m ) string_functions_s implicit none contains module procedure file_extension character ( len = :), allocatable :: name_ name_ = trim ( file_name ) associate ( dot_location => index ( name_ , '.' , back = . true .) ) if ( dot_location < len ( name_ )) then extension = name_ ( dot_location + 1 :) else extension = \"\" end if end associate end procedure module procedure base_name character ( len = :), allocatable :: name_ name_ = trim ( file_name ) associate ( dot_location => index ( name_ , '.' , back = . true .) ) if ( dot_location < len ( name_ )) then base = name_ ( 1 : dot_location - 1 ) else base = \"\" end if end associate end procedure module procedure integer_to_string integer , parameter :: max_characters = 16 character ( len = max_characters ) string write ( string , * ) integer_value characters = trim ( adjustl ( string )) end procedure end submodule","tags":"","loc":"sourcefile/string_functions_s.f90.html"},{"title":"string_s.f90 – ","text":"This file depends on sourcefile~~string_s.f90~~EfferentGraph sourcefile~string_s.f90 string_s.f90 sourcefile~string_m.f90 string_m.f90 sourcefile~string_s.f90->sourcefile~string_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules string_s Source Code string_s.f90 Source Code submodule ( string_m ) string_s implicit none contains module procedure construct new_string % string_ = string end procedure module procedure string raw_string = self % string_ end procedure module procedure is_allocated string_allocated = allocated ( self % string_ ) end procedure module procedure array_of_strings character ( len = :), allocatable :: remainder , next_string integer next_delimiter , string_end remainder = trim ( adjustl ( delimited_strings )) allocate ( strings_array ( 0 )) do next_delimiter = index ( remainder , delimiter ) string_end = merge ( len ( remainder ), next_delimiter - 1 , next_delimiter == 0 ) next_string = trim ( adjustl ( remainder (: string_end ))) if ( len ( next_string ) == 0 ) exit strings_array = [ strings_array , string_t ( next_string )] if ( next_delimiter == 0 ) then remainder = \"\" else remainder = trim ( adjustl ( remainder ( next_delimiter + 1 :))) end if end do end procedure end submodule string_s","tags":"","loc":"sourcefile/string_s.f90.html"},{"title":"string_functions_m.f90 – ","text":"Files dependent on this one sourcefile~~string_functions_m.f90~~AfferentGraph sourcefile~string_functions_m.f90 string_functions_m.f90 sourcefile~string_functions_s.f90 string_functions_s.f90 sourcefile~string_functions_s.f90->sourcefile~string_functions_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules string_functions_m Source Code string_functions_m.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module string_functions_m !! author: Damian Rouson !! date: August 23, 2019 !! summary: utilities for manipulating or producing character variables implicit none private public :: file_extension , base_name , string interface string module procedure integer_to_string end interface interface pure module function file_extension ( file_name ) result ( extension ) !! result contains all characters in file_name after the first dot (.) character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: extension end function pure module function base_name ( file_name ) result ( base ) !! result contains all characters in file_name before the first dot (.) character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: base end function pure module function integer_to_string ( integer_value ) result ( characters ) integer , intent ( in ) :: integer_value character ( len = :), allocatable :: characters end function end interface end module","tags":"","loc":"sourcefile/string_functions_m.f90.html"},{"title":"co_object_m.f90 – ","text":"Files dependent on this one sourcefile~~co_object_m.f90~~AfferentGraph sourcefile~co_object_m.f90 co_object_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~co_object_m.f90 sourcefile~co_object_implementation.f90 co_object_implementation.f90 sourcefile~co_object_implementation.f90->sourcefile~co_object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules co_object_m Source Code co_object_m.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module co_object_m implicit none private public :: co_object ! Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types. ! Each non-abstract type provides the functionality by extending self type and implementing its deferred binding(s).  This ! type resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other type. type , abstract :: co_object private logical :: defined = . false . !! Default initialization indicates not yet user-defined logical , allocatable :: facilitate_type_extension [:] contains procedure :: mark_as_defined procedure :: user_defined end type interface pure module subroutine mark_as_defined ( self ) !! Mark the co_object as user-defined implicit none class ( co_object ), intent ( inout ) :: self end subroutine pure module function user_defined ( self ) result ( is_defined ) !! Return a boolean result indicating whether self co_object has been initialized since its declaration implicit none class ( co_object ), intent ( in ) :: self logical :: is_defined end function end interface end module co_object_m","tags":"","loc":"sourcefile/co_object_m.f90.html"},{"title":"units_m.f90 – ","text":"Files dependent on this one sourcefile~~units_m.f90~~AfferentGraph sourcefile~units_m.f90 units_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~units_m.f90 sourcefile~units_s.f90 units_s.f90 sourcefile~units_s.f90->sourcefile~units_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules units_m Source Code units_m.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module units_m !! author: Damian Rouson !! date: 9/9/2019 !! !! Define SI and British units of measurement and associated arithmetic operators implicit none private public :: units public :: K , m , kg , sec public :: R , ft , lbm public :: dimensionless , SI , British public :: num_fundamental public :: units_system_names public :: SI_units_names , British_units_names enum , bind ( C ) !! Enumerate the fundamental units for dimensional units quantities !! (meters, kilograms, seconds, and degrees Kelvin) enumerator :: K = 1 , m , kg , sec enumerator :: R = 1 , ft , lbm enumerator :: dimensionless = 0 , SI , British end enum integer , parameter :: num_fundamental = 4 , num_systems = 2 character ( len =* ), parameter :: units_system_names ( num_systems ) = [ character ( len = len ( \"British\" )) :: \"SI\" , \"British\" ] character ( len =* ), parameter :: SI_units_names ( num_fundamental ) = [ character ( len = len ( \"sec\" )) :: \"K\" , \"m\" , \"kg\" , \"sec\" ] character ( len =* ), parameter :: British_units_names ( num_fundamental ) = [ character ( len = len ( \"sec\" )) :: \"R\" , \"ft\" , \"lbm\" , \"sec\" ] type units !! Morfeus universal base type for all units private integer :: exponents_ ( num_fundamental ) = dimensionless !! Store the exponents for fundamental units integer :: system = dimensionless !! Default to SI units character ( len = :), allocatable :: description contains procedure :: set_units procedure :: get_units procedure :: get_system procedure :: is_dimensionless procedure :: has_length_units procedure :: has_mass_units procedure :: has_time_units procedure :: has_temperature_units procedure :: has_velocity_units procedure :: has_energy_units procedure :: has_density_units procedure :: has_specific_energy_units procedure :: has_stress_units procedure :: has_power_units procedure :: add procedure :: multiply procedure :: divide procedure :: subtract , negate procedure :: integer_power procedure :: real_power procedure :: assign_units generic :: operator ( + ) => add generic :: operator ( * ) => multiply generic :: operator ( / ) => divide generic :: operator ( - ) => subtract , negate generic :: operator ( ** ) => integer_power , real_power generic :: assignment ( = ) => assign_units end type interface pure module subroutine set_units ( this , exponents , system ) !! define units implicit none class ( units ), intent ( inout ) :: this integer , intent ( in ) :: exponents ( num_fundamental ) integer , intent ( in ) :: system end subroutine pure module subroutine assign_units ( lhs , rhs ) !! copy units information implicit none class ( units ), intent ( inout ) :: lhs class ( units ), intent ( in ) :: rhs end subroutine impure elemental module function integer_power ( this , exponent_ ) result ( this_raised ) !! result has units of the opearand raised to the power \"exponent_\" implicit none class ( units ), intent ( in ) :: this integer , intent ( in ) :: exponent_ type ( units ) :: this_raised end function module function get_units ( this ) result ( exponents ) !! result holds the exponents of each unit in the argument (most useful when the actual argument is an expression) implicit none class ( units ), intent ( in ) :: this integer :: exponents ( num_fundamental ) end function impure elemental module function get_system ( this ) result ( system_of_units ) !! result is enumerated value designating units system implicit none class ( units ), intent ( in ) :: this integer :: system_of_units end function impure elemental module function real_power ( this , exponent_ ) result ( this_raised ) !! result is the units of the operand raised to the power \"exponent_\"; includes check that operand is dimensionless implicit none class ( units ), intent ( in ) :: this real , intent ( in ) :: exponent_ type ( units ) :: this_raised end function impure elemental module function add ( lhs , rhs ) result ( total ) !! result is the units of the sum of two dimensional quantities; includes operand consistency check implicit none class ( units ), intent ( in ) :: lhs , rhs type ( units ) :: total end function impure elemental module function subtract ( lhs , rhs ) result ( difference ) !! result is the units of the difference of two dimensional quantities; includes operand consistency check implicit none class ( units ), intent ( in ) :: lhs , rhs type ( units ) :: difference end function elemental module function negate ( this ) result ( negative_this ) !! result is the units of the negative of a dimensional quantities implicit none class ( units ), intent ( in ) :: this type ( units ) :: negative_this end function elemental module function multiply ( lhs , rhs ) result ( product_ ) !! result is the units of the product of two dimensional quantities; includes units-system consistency check implicit none class ( units ), intent ( in ) :: lhs , rhs type ( units ) :: product_ end function elemental module function divide ( numerator , denominator ) result ( ratio ) !! result is the units of the ratio of two dimensional quantities; includes units-sysetm consistency check implicit none class ( units ), intent ( in ) :: numerator , denominator type ( units ) :: ratio end function elemental module function is_dimensionless ( this ) result ( nondimensional ) !! Return true if all units exponents are zero; false otherwise. implicit none class ( units ), intent ( in ) :: this logical :: nondimensional end function elemental module function has_length_units ( this ) result ( length_units ) !! Return true if units match meters (m) implicit none class ( units ), intent ( in ) :: this logical :: length_units end function elemental module function has_mass_units ( this ) result ( mass_units ) !! Return true if units match kilograms (kg) implicit none class ( units ), intent ( in ) :: this logical :: mass_units end function elemental module function has_time_units ( this ) result ( time_units ) !! Return true if units match seconds (s) implicit none class ( units ), intent ( in ) :: this logical :: time_units end function elemental module function has_temperature_units ( this ) result ( temperature_units ) !! Return true if units match degrees Kelvin (K) implicit none class ( units ), intent ( in ) :: this logical :: temperature_units end function elemental module function has_velocity_units ( this ) result ( velocity_units ) !! Return true if units match meters/second&#94;2 (m/s&#94;2) implicit none class ( units ), intent ( in ) :: this logical :: velocity_units end function elemental module function has_energy_units ( this ) result ( energy_units ) !! Return true if units match joules (J) implicit none class ( units ), intent ( in ) :: this logical :: energy_units end function elemental module function has_density_units ( this ) result ( density_units ) !! Return true if units match kilograms (kg/m&#94;3) implicit none class ( units ), intent ( in ) :: this logical :: density_units end function elemental module function has_specific_energy_units ( this ) result ( specific_energy_units ) !! Return true if units match Joules per kilogram (J/kg) implicit none class ( units ), intent ( in ) :: this logical :: specific_energy_units end function elemental module function has_stress_units ( this ) result ( stress_units ) !! Return true if units match Newtons per square meter (N/m&#94;2) implicit none class ( units ), intent ( in ) :: this logical :: stress_units end function elemental module function has_power_units ( this ) result ( power_units ) !! Return true if units match Watts (W) implicit none class ( units ), intent ( in ) :: this logical :: power_units end function end interface end module","tags":"","loc":"sourcefile/units_m.f90.html"},{"title":"user_defined_collectives_m.f90 – ","text":"Files dependent on this one sourcefile~~user_defined_collectives_m.f90~~AfferentGraph sourcefile~user_defined_collectives_m.f90 user_defined_collectives_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~user_defined_collectives_m.f90 sourcefile~user_defined_collectives_s.f90 user_defined_collectives_s.f90 sourcefile~user_defined_collectives_s.f90->sourcefile~user_defined_collectives_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules user_defined_collectives_m Source Code user_defined_collectives_m.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module user_defined_collectives_m !! author: Damian Rouson !! !! This module contains user-defined collective subroutines. implicit none interface module subroutine co_all ( boolean ) !! If any image in a team calls this subroutine, then every image in the !! the same team must call this subroutine.  This subroutine sets the !! \"boolean\" argument .true. if it is true in all participating images !! upon entry and .false. otherwise. implicit none logical , intent ( inout ) :: boolean end subroutine end interface end module user_defined_collectives_m","tags":"","loc":"sourcefile/user_defined_collectives_m.f90.html"},{"title":"string_m.f90 – ","text":"Files dependent on this one sourcefile~~string_m.f90~~AfferentGraph sourcefile~string_m.f90 string_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~string_m.f90 sourcefile~file_m.f90 file_m.f90 sourcefile~sourcery_m.f90->sourcefile~file_m.f90 sourcefile~string_s.f90 string_s.f90 sourcefile~string_s.f90->sourcefile~string_m.f90 sourcefile~file_m.f90->sourcefile~string_m.f90 sourcefile~file_s.f90 file_s.f90 sourcefile~file_s.f90->sourcefile~file_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules string_m Source Code string_m.f90 Source Code module string_m implicit none private public :: string_t public :: array_of_strings type string_t private character ( len = :), allocatable :: string_ contains procedure :: string procedure :: is_allocated end type interface string_t elemental module function construct ( string ) result ( new_string ) implicit none character ( len =* ), intent ( in ) :: string type ( string_t ) new_string end function end interface interface pure module function string ( self ) result ( raw_string ) implicit none class ( string_t ), intent ( in ) :: self character ( len = :), allocatable :: raw_string end function pure module function array_of_strings ( delimited_strings , delimiter ) result ( strings_array ) implicit none character ( len =* ), intent ( in ) :: delimited_strings , delimiter type ( string_t ), allocatable :: strings_array (:) end function elemental module function is_allocated ( self ) result ( string_allocated ) implicit none class ( string_t ), intent ( in ) :: self logical string_allocated end function end interface end module string_m","tags":"","loc":"sourcefile/string_m.f90.html"},{"title":"test_s.f90 – ","text":"This file depends on sourcefile~~test_s.f90~~EfferentGraph sourcefile~test_s.f90 test_s.f90 sourcefile~test_m.f90 test_m.f90 sourcefile~test_s.f90->sourcefile~test_m.f90 sourcefile~test_result_m.f90 test_result_m.f90 sourcefile~test_m.f90->sourcefile~test_result_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules test_s Source Code test_s.f90 Source Code submodule ( test_m ) test_s implicit none contains module procedure report integer i print * print * , test % subject () associate ( test_results => test % results ()) associate ( num_tests => size ( test_results )) tests = tests + num_tests do i = 1 , num_tests print * , \"   \" , test_results ( i )% characterize () end do associate ( num_passes => count ( test_results % passed ())) print '(a,2(i0,a))' , \" \" , num_passes , \" of \" , num_tests , \" tests pass.\" passes = passes + num_passes end associate end associate end associate end procedure end submodule test_s","tags":"","loc":"sourcefile/test_s.f90.html"},{"title":"command_line_s.f90 – ","text":"This file depends on sourcefile~~command_line_s.f90~~EfferentGraph sourcefile~command_line_s.f90 command_line_s.f90 sourcefile~command_line_m.f90 command_line_m.f90 sourcefile~command_line_s.f90->sourcefile~command_line_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules command_line_s Source Code command_line_s.f90 Source Code submodule ( command_line_m ) command_line_s implicit none contains module procedure argument_present !! list of acceptable arguments !! sample list: [character(len=len(longest_argument)):: \"--benchmark\", \"-b\", \"/benchmark\", \"/b\"] !! where dashes support Linux/macOS and slashes support Windows integer :: i , argnum , arglen !! loop counter, argument position, argument length character ( len = 32 ) arg !! argument position !! acceptable argument lengths (used to preclude extraneous trailing characters) associate ( acceptable_length => [( len ( trim ( acceptable_argument ( i ))), i = 1 , size ( acceptable_argument ))]) found = . false . do argnum = 1 , command_argument_count () call get_command_argument ( argnum , arg , arglen ) if ( any ( & [( arg == acceptable_argument ( i ) . and . arglen == acceptable_length ( i ), i = 1 , size ( acceptable_argument ))] & )) then found = . true . end if end do end associate end procedure module procedure flag_value integer argnum , arglen , flag_value_length character ( len = :), allocatable :: arg flag_search : & do argnum = 1 , command_argument_count () call get_command_argument ( argnum , length = arglen ) allocate ( character ( len = arglen ) :: arg ) call get_command_argument ( argnum , arg ) if ( arg == flag ) then call get_command_argument ( argnum + 1 , length = flag_value_length ) allocate ( character ( len = flag_value_length ) :: flag_value ) call get_command_argument ( argnum + 1 , flag_value ) exit flag_search end if end do flag_search end procedure end submodule","tags":"","loc":"sourcefile/command_line_s.f90.html"},{"title":"co_object_implementation.f90 – ","text":"This file depends on sourcefile~~co_object_implementation.f90~~EfferentGraph sourcefile~co_object_implementation.f90 co_object_implementation.f90 sourcefile~co_object_m.f90 co_object_m.f90 sourcefile~co_object_implementation.f90->sourcefile~co_object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules co_object_s Source Code co_object_implementation.f90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( co_object_m ) co_object_s implicit none contains module procedure mark_as_defined self % defined = . true . end procedure module procedure user_defined is_defined = self % defined end procedure end submodule","tags":"","loc":"sourcefile/co_object_implementation.f90.html"},{"title":"test_result_s.f90 – ","text":"This file depends on sourcefile~~test_result_s.f90~~EfferentGraph sourcefile~test_result_s.f90 test_result_s.f90 sourcefile~test_result_m.f90 test_result_m.f90 sourcefile~test_result_s.f90->sourcefile~test_result_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules test_result_s Source Code test_result_s.f90 Source Code submodule ( test_result_m ) test_result_s implicit none contains module procedure construct test_result % description_ = description test_result % passed_ = passed end procedure module procedure characterize characterization = trim ( merge ( \"passes on \" , \"FAILS on  \" , self % passed_ )) // \" \" // trim ( self % description_ ) // \".\" end procedure module procedure passed test_passed = self % passed_ end procedure end submodule test_result_s","tags":"","loc":"sourcefile/test_result_s.f90.html"},{"title":"oracle_s.f90 – ","text":"This file depends on sourcefile~~oracle_s.f90~~EfferentGraph sourcefile~oracle_s.f90 oracle_s.f90 sourcefile~oracle_m.f90 oracle_m.f90 sourcefile~oracle_s.f90->sourcefile~oracle_m.f90 sourcefile~object_m.f90 object_m.f90 sourcefile~oracle_m.f90->sourcefile~object_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules oracle_s Source Code oracle_s.f90 Source Code submodule ( oracle_m ) oracle_s !! define procedures corresponding to the interface bodies in oracle_m implicit none contains module procedure within_tolerance class ( oracle_t ), allocatable :: error error = self - reference in_tolerance = ( error % norm () <= tolerance ) end procedure end submodule oracle_s","tags":"","loc":"sourcefile/oracle_s.f90.html"},{"title":"object_m.f90 – ","text":"Files dependent on this one sourcefile~~object_m.f90~~AfferentGraph sourcefile~object_m.f90 object_m.f90 sourcefile~oracle_m.f90 oracle_m.f90 sourcefile~oracle_m.f90->sourcefile~object_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~object_m.f90 sourcefile~sourcery_m.f90->sourcefile~oracle_m.f90 sourcefile~object_s.f90 object_s.f90 sourcefile~object_s.f90->sourcefile~object_m.f90 sourcefile~oracle_s.f90 oracle_s.f90 sourcefile~oracle_s.f90->sourcefile~oracle_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules object_m Source Code object_m.f90 Source Code ! ### Copyright notice ! !     ``` !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 !     ``` module object_m implicit none private public :: object_t type , abstract :: object_t !! author: Damian Rouson, GSE LLC !! category: Morfeus-FD !! summary: Abstract type to ensure all objects extending it implement the required methods !! !! Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types. !! Each non-abstract type provides the functionality by extending self type and implementing its deferred binding(s).  This !! type resembles java's Object class in the sense that it is intended to be the ultimate ancestor of every other type. private logical :: defined = . false . !! Default initialization indicates not yet user-defined contains procedure :: mark_as_defined procedure :: user_defined procedure ( write_interface ), deferred :: write_formatted generic :: write ( formatted ) => write_formatted end type interface pure module subroutine mark_as_defined ( self ) !! Mark the object as user-defined implicit none class ( object_t ), intent ( inout ) :: self end subroutine pure module function user_defined ( self ) result ( is_defined ) !! Return a boolean result indicating whether self object has been initialized since its declaration implicit none class ( object_t ), intent ( in ) :: self logical :: is_defined end function end interface abstract interface subroutine write_interface ( self , unit , iotype , v_list , iostat , iomsg ) import object_t implicit none class ( object_t ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg end subroutine end interface end module object_m","tags":"","loc":"sourcefile/object_m.f90.html"},{"title":"test_m.f90 – ","text":"This file depends on sourcefile~~test_m.f90~~EfferentGraph sourcefile~test_m.f90 test_m.f90 sourcefile~test_result_m.f90 test_result_m.f90 sourcefile~test_m.f90->sourcefile~test_result_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~test_m.f90~~AfferentGraph sourcefile~test_m.f90 test_m.f90 sourcefile~sourcery_m.f90 sourcery_m.f90 sourcefile~sourcery_m.f90->sourcefile~test_m.f90 sourcefile~test_s.f90 test_s.f90 sourcefile~test_s.f90->sourcefile~test_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules test_m Source Code test_m.f90 Source Code module test_m !! Define an abstract test_t type with deferred bindings (\"subject\" and \"results\") !! used by a type-bound procedure (\"report\") for reporting test results.  The \"report\" !! procedure thus represents an implementation of the Template Method pattern. use test_result_m , only : test_result_t implicit none private public :: test_t , test_result_t type , abstract :: test_t !! Facilitate testing and test reporting contains procedure ( subject_interface ), nopass , deferred :: subject procedure ( results_interface ), nopass , deferred :: results procedure :: report end type abstract interface pure function subject_interface () result ( specimen ) !! The result is the name of the test specimen (the subject of testing) character ( len = :), allocatable :: specimen end function function results_interface () result ( test_results ) !! The result is an array of test results for subsequent reporting in the \"report\" type-bound procedure import test_result_t type ( test_result_t ), allocatable :: test_results (:) end function end interface interface module subroutine report ( test , passes , tests ) !! Print the test results and increment the tallies of passing tests and total tests implicit none class ( test_t ), intent ( in ) :: test integer , intent ( inout ) :: passes , tests end subroutine end interface end module test_m","tags":"","loc":"sourcefile/test_m.f90.html"}]}